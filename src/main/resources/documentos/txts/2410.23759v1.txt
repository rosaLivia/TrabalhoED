
[Página 1]
M. Marin, L. Leu¸ stean (Eds.): 8th Symposium on Working Formal Methods (FROM 2024) EPTCS 410, 2024, pp. 53–68, doi:10.4204/EPTCS.410.4This work is licensed under the Creative Commons Attribution-Share Alike License.Converting BPMN Diagrams to Privacy Calculus Georgios V . Pitsiladis Petros S. Stefaneas Department of Mathematics School of Applied Mathematical and Physical Sciences National Technical University of Athens 9 Iroon Polytechniou Str., 15772 Zografou, Greece gpitsiladis@mail.ntua.gr petros@math.ntua.gr The ecosystem of Privacy Calculus is a formal framework for privacy comprising (a) the Privacy Calculus, a Turing-complete language of message-exchanging processes based on the π-calculus, (b) a privacy policy language, and (c) a type checker that checks adherence of Privacy Calculus terms to privacy policies. BPMN is a standard for the graphical description of business processes which aims to be understandable by all business users, from those with no technical background to those implementing software. This paper presents how (a subset of) BPMN diagrams can be converted to Privacy Calculus terms, in the hope that it will serve as a small piece of larger workflows for building privacy-preserving software. The conversion is described mathematically in the paper, but has also been implemented as a software tool. 1 Introduction The main motivation of this paper is that it might serve as a first version of a piece of a larger workflow for building privacy-preserving software. In order to trust that some piece of software is privacy-preserving, this must somehow be proved formally; in other words, privacy protection needs to be considered as a formal specification (formalised privacy policies) complemented by tools able to decide adherence of programs to policies. The Privacy Calculus ecosystem has been introduced in [10] to tackle these considerations; it was further developed in [11, 9, 17, 16, 12, 23]. Privacy Calculus is a variation of the π-calculus, a Turing- complete language describing parallel processes sharing messages. It is accompanied by a privacy policy language, which gives the ability to grant permissions (read, write, disclose, store, etc.) to users orgroups (forming a hierarchy) for specific purposes1. The ecosystem is completed by a type checker for checking compliance of Privacy Calculus terms to privacy policies written in the aforementioned formal language. Although some tools for working with the Privacy Calculus ecosystem have been created [18, 22], the ecosystem is still quite abstract, far from everyday practice. One way to bridge this gap is to cre- ate conversions between higher-level frameworks and Privacy Calculus. This is where BPMN might fruitfully enter the discussion. The aim of Business Process Model and Notation (BPMN) is to serve as a standard for the graphical depiction of business processes, enhancing intra- and inter-organisational communication and interoper- ability. It is high-level enough to be understandable by audiences with minimal technical background, however it can be quite detailed and (in its full generality) even automatically executable. This paper is an exploration of how the most basic elements of BPMN can be converted to Privacy Calculus terms with the hope that eventually, a workflow such as the following could be feasible: (1) de- scribe a business process in BPMN, (2) convert it to Privacy Calculus, (3) specify a privacy policy, ideally 1The notion of purpose is inherent in privacy protection. This has been argued in the literature regarding privacy, but has also been acknowledged in practice by legislation: purpose of data processing is a fundamental notion in GDPR.

[Página 2]
54 Converting BPMN Diagrams to Privacy Calculus by converting it from some high-level framework to the formal privacy policy language, (4) obtain (e.g. with the Maude tool presented in [18]) a proof that the business process adheres to the policy. The rest of this paper is organised as follows: Section 2 reviews basic notions of BPMN, Section 3 contains some basic definitions of the Privacy Calculus, and Section 4 discusses how BPMN diagrams (or rather, a subset of them) can be converted to Privacy Calculus terms and presents a tool that automates the said conversion; Section 5 contains some concluding remarks. 2 Business Process Model and Notation BPMN defines, both syntactically and semantically, a multitude of graphical elements. These elements can be combined into diagrams. Three kinds of diagrams are possible: Collaborations, Processes, and Choreographies ([14, Section 1.1]); here, only the first two will be considered. Processes can be public or private. Private Processes model activities within an organisation: they can be defined at a so high level of detail as to be executable; otherwise, they serve for documentation purposes. Public Processes are non-executable and show activities of multiple Participants, documenting their interaction and hiding (parts of) actions internal to Participants [14, Section 7.2.1]. Here, since the interest lies on data protection among multiple stakeholders (the data subject and at least one data pro- cessing entity), mostly public Processes will be considered. Figs. 1a and 1b are examples of Processes. A Collaboration contains two or more Participants and its purpose is to depict the interactions among them [14, Section 7.2.1]. Each Participant is depicted as a Pool which may be empty or contain a Process diagram [14, Table 7.1] (at most one process can be private, in which case it may be drawn outside of a Pool [14, Section 9.3]). Pools can also be divided in Lanes and/or have multiple instances, but these features will not be considered here. Fig. 2 is an example of a Collaboration with two Pools. There are five categories of graphical elements [14, Section 7.3]: flow objects (Events, Activities, Gateways), data (Data Objects, Data Stores), connecting objects (Sequence Flows, Message Flows, Associations, Data Associations), swimlanes (Pools, Lanes), and artifacts (Text Annotations, element Groups). Here, only flow objects, Flows, and Pools will be considered; the main characteristics of Events, Activities, Gateways, and Flows will be presented in Sections 2.1 to 2.4. Data Objects and Data Stores will not be considered, since the version of Privacy Calculus employed here cannot deal with them properly. Messages will only be considered indirectly, because they are not supported by the bpmn.io diagram editor; when needed, they will be considered as available externally to the BPMN modelling. In order to understand how control flows within a diagram, the concept of tokens is employed in lieu of semantics; in the words of [14, Section 7.2], “A token is a theoretical concept that is used as an aid to define the behavior of a Process that is being performed. The behavior of Process elements can be defined by describing how they interact with a token as it ‘traverses’ the structure of the Process.”. In short (and with many details omitted), Start Events generate tokens, End Events consume them, and the other elements redirect, multiply, or merge them appropriately. Tokens will be instrumental for the conversion to Privacy Calculus. 2.1 Events There are three types of Events2based on when they affect the flow of a process: Start, Intermediate, and End. There are also multiple types of events depending on how the affect the flow: here, only Message Events (and Start/End events with no information as to how they affect the flow) will be considered. 2BPMN also defines Events at the boundaries of Activities [14, Section 10.5.4], but these will not be considered here.

[Página 3]
G. V . Pitsiladis, P. S. Stefaneas 55 Every Event either catches or throws (but not both): Start Events always catch, End Events always throw, Intermediate Message Events may do either. [14, Section 7.3.2] Contrary to [14, Section 10.5.2 and Section 7.2.1], which allow leaving Start/End events implicit for simplicity, this paper requires that Processes (and Sub-Processes) must always start with one or more Start Events and that each path of a Process (or Sub-Process) must terminate at an End Event. This affects expressiveness only minimally; moreover, in future treatments, “phantom” Start/End Events, connected to the “initial” and “final” Flow Nodes, could be added if none are provided. Naturally, Start Events have no incoming Sequence Flows and End Events have no outgoing Se- quence Flows. In order to accommodate implicit Start/End Events, BPMN ([14, Section 10.5.2]) allows this for other Flow Nodes as well. Here, the only Flow Nodes that will be permitted not to have an incoming Sequence Flow are Start Events; dually, the only Flow Nodes that will be permitted not to have an outgoing Sequence Flow are End Events and Sub-processes. (a) A Process with only Message Events as Flow Nodes. From start to end, it contains a Message Start Event, a Message Intermediate Catch Event, a Message Intermediate Throw Event, and a Message End Event. (b) A Process with some Conditional Flows (recognised by the diamond symbol at their start). The Start Event is followed by a Receive Task. Depending on the conditions, one or both of the following two Abstract Tasks are triggered; here, it is assumed that the conditions are such that only one can be fulfilled. An Exclusive Gateway combines the two alternative paths and channels the flow to the End Event. Figure 1: Two diagrams of BPMN Processes. 2.2 Activities Activities are divided into Tasks and Sub-Processes. Tasks are atomic (as far as the modelling is con- cerned), while Sub-Processes are compound [14, Section 7.3.2]. Tasks: A Task is an Activity which represents some action not broken down to more detail, hence considered atomic (in fact, it might be cancelled in mid-execution through the Compensation or other mechanisms of BPMN, but this is not considered here). There are many types of Tasks, including a generic one (Abstract Tasks). Apart from Abstract Tasks, this paper is mainly interested in Send Tasks (e.g. “Send confirmation receipt” in Fig. 2), which send Messages to other Participants, and Receive Tasks (e.g. “Listen for confirmation” in Fig. 2), which receive Messages from other Participants. Among the rest types of Tasks are User Tasks (e.g. “Receive notification” in Fig. 2), which are executed by humans with the aid of automated systems, and Manual Tasks, which are executed by humans manually (e.g. “Send response” in Fig. 2; imagine that the response is sent via traditional mail).

[Página 4]
56 Converting BPMN Diagrams to Privacy Calculus Some simplifying conventions (limiting the expressiveness of our tool) will be made. Contrary to [14, Section 10.3], here it will be assumed that every Task has at most (hence, exactly) one incoming Sequence Flow, at most one incoming Message Flow, and at most one outgoing Message Flow. Also, looping and multiplicity of Tasks will not be considered here. Sub-Processes: BPMN defines some special types of Sub-Processes; here, however, we will only be interested in those that are just Processes within Processes (Embedded Sub-Processes). Examples can be seen in Fig. 2. Sub-Processes may have parallel multiplicity, i.e. multiple copies of a Sub-Process may run in parallel (looping or sequential multiplicity are also options in BPMN, but will not be considered here). Recall that here we require Sub-Processes to always contain at least one Start and one End Event. As for Tasks, contrary to [14, Section 10.3], here it will be assumed that every Sub-Process has at most (hence, exactly) one incoming Sequence Flow. Figure 2: A BPMN diagram depicting a Collaboration. Here, the “Service” Pool has two Sub-Processes. These Sub-Processes have multiple (parallel) instances, indicated by the parallel lines at their bottom. 2.3 Flows Flows are drawn as arrows. There are two kinds of flows: Sequence Flows (solid arrows) and Message Flows (dashed arrows). Sequence Flows: Sequence Flows model the flow of control within a Process. An Uncontrolled Flow (i.e. a Normal Flow not connected to some Gateway and not affected by Conditions) is the most basic kind of Flow, representing the order of execution of the elements it connects. Conditional Flows (examples can be seen in Fig. 1b) are only activated if their corresponding Con- dition is met. Here, Conditional Flows will be considered only when they are outgoing from a Receive

[Página 5]
G. V . Pitsiladis, P. S. Stefaneas 57 Task (their Condition shall then pertain to the received message). Default Flows will not be considered. Non-Normal Sequence Flows (pertaining to Exceptions and Compensations), as well as looping via “backwards” sequence flows, will not be considered here. Of course, the restrictions on Flows heavily impact the expressiveness of the diagrams our tool can handle. However, the supported elements are already expressive enough to be considered in this version. Message Flows: Message Flows depict the flow of messages between Participants in a Collabora- tion [14, Section 7.3.2] (see Fig. 2). According to [14, Chapter 10], “All Message Flows must connect two separate Pools. They may connect to the Pool boundary or to Flow Objects within the Pool bound- ary.”. In this paper, each Message Flow must have a Flow Object as either source or target. Contrary to [14, Section 7.6.2], here it will be assumed that Sub-Processes per se have neither incoming nor out- going Message Flows. Flow Nodes within a Sub-Process will support Message Flows as usual. 2.4 Gateways Gateways control the convergence and divergence of Sequence Flows. Here, only Parallel and Exclusive Gateways will be considered (the latter only in their converging form). A Gateway must have multi- ple incoming Sequence Flows or multiple outgoing Sequence Flows (or multiple of both, which is not recommended) [14, Section 10.6]; recall that here it is also required to have at least one of each. “Gate- ways do not represent ‘work’ being done and they are considered to have zero effect on the operational measures of the Process being executed (cost, time, etc.).” [14, Section 10.6] Parallel Gateways (e.g. the one synchronising the Tasks “Send confirmation receipt” and “Send response” in Fig. 2) create and synchronise parallel paths: that is, when multiple Flows are outgoing from a Parallel Gateway, all of them will be executed in parallel; dually, when multiple Flows are incoming to a Parallel Gateway, it will wait until all of them are executed before activating its output Flows. According to [14, Section 10.6.2], “A converging Exclusive Gateway [i.e. one with multiple incom- ing Sequence Flows and one outgoing Sequence Flow] is used to merge alternative paths. Each incoming Sequence Flow token is routed to the outgoing Sequence Flow without synchronization.”. Here, we will only consider cases where the incoming Sequence Flows to the Exclusive Gateway are alternative, i.e. that at most one of them can be triggered. An example of an Exclusive Gateway can be seen in Fig. 1b. 3 Privacy Calculus The Privacy Calculus is a typed variant of the π-calculus introduced in [10] and further developed in [11, 9, 17, 16, 12, 23]. The version of the Privacy Calculus presented here is the one of [18], with the addition of the Choice and Silent operators which are standard in π-calculus and can be introduced in the tool of [18] with minimal effort (amounting to the addition of two transition rules, i.e. (Choice) and (Silent) of Fig. 3, and two simple typing rules). Assume the following basic sets of entities: (1) an infinitely countable set of channel names (ranged over by x,y,z,a,b), (2) a set of basic types, (3) a set of purposes (ranged over by u), (4) a set of groups, (ranged over by G), split into a set of users, (ranged over by U) and a set of roles (ranged over by R); for any two groups G1,G2, their union G1∪G2is also a group (notice that privacy policies support group hierarchies), (5) a set of context variables X, where each X∈Xhas a finite domain DXof possible values ranged over by vX;vranges over the unionS XDX. The following can then be defined: (1) a set of names Ncontaining channel names and all the values of context variables, (2) a set of types T(ranged over by T), containing all basic types, all

[Página 6]
58 Converting BPMN Diagrams to Privacy Calculus context variables, and every element of the form G[T](the intuition being that a name of type G[T]can be used by processes that “belong” to group Gin order to exchange messages of type T). Terms of the Privacy Calculus are defined in two levels, processes and systems: Process P ::=0 Empty |x(x:T).P Input |x⟨x⟩.P Output |τ.P Silent |(νx:T)P Create channel |P|P Parallel |P+P Choice |[x=v](P;P)Conditional |!P ReplicationSystem S ::=0 Empty |(νx:T)SCreate channel |S∥S Parallel |R[S] Bind group |G:u[P] Process lift Processes are standard in π-calculus: the empty process does nothing, the input x(y:T).Preceives yof type Tvia the channel x(binding the name yinP) and continues as P, the output x⟨y⟩.Psends y via the channel xand continues as P, the silent process τ.Pdoes some unspecified internal work and then continues as P, the process (νx:T)Pcreates a channel xof type T(and binds the name x) in P, the parallel composition P1|P2combines the two processes so that both run in parallel, the choice composition P1+P2combines the two processes so that only one will run, the conditional [x=v](P1;P2) checks whether xis equal to vand if so continues as P1, otherwise as P2, and the replication ! Pbehaves asP|!P. For brevity, define [x=v]Pas[x=v](P;0),[x̸=v]Pas[x=v](0;P),∏n i=1PiasP1|...|Pn, and∑n i=1PiasP1+...+Pn. Systems annotate processes with high-level privacy information. The system G:u[P]declares that the process Pruns on behalf of group Gfor the purpose u, the system R[S]declares that the system S runs for the role R(in addition to any other groups declared in S), while the empty, name binding, and parallel systems are similar to the respective processes. For brevity, define ∏n i=1SiasS1∥...∥Sn. For the unambiguous treatment of bound names, CINNI [21] is employed: it adds indices to names, so that, for example, the term (νx:T)x⟨y⟩.(νx:T)x⟨y⟩.0is actually interpreted as (νx1:T)x1⟨y⟩.(νx0: T)x0⟨y⟩.0. Thus, name substitution [a:=b](substitute all free occurrences of awith b) can be de- fined elegantly. For technical reasons, CINNI defines some operators that convert indices, such that [shiftdown aX], which decreases the indices of every ainXby 1 (not going below 0). In this paper, CINNI will be ignored, i.e. indices of channel names will always be omitted and the index 0 will be assumed for all channel names. Two processes/systems that differ only in the selection of their bound names are called α-equivalent. Structural congruence (i.e. behavioural equivalence) of processes/systems, denoted ≡, is defined as follows: (1) α-equivalent terms are congruent, (2) parallel/choice terms that differ only in the order of their operands are congruent (i.e. parallel and choice operators are associative and commutative), (3) repetitions of operands in choice is irrelevant (i.e. the choice operator is idempotent), (4) P|0≡P, S∥0≡S, !0≡0,(νx:T)0≡0(both for processes and systems), G[0]≡0,G:u[0]≡0. The operational semantics of the Privacy Calculus is defined in Fig. 3. It is a late labelled transition semantics comprising four kinds of labels: (1) silent,τ− →, (2) input,x(y)− − →, (3) output,x⟨y⟩− − →, (4) bound output(νy:T)x⟨y⟩− − − − − − → . Notice that the π-calculus, and hence Privacy Calculus, is non-deterministic: multiple execution steps might be possible for a given term, in which case any one of them might be selected arbitrarily as the next to be executed.

[Página 7]
G. V . Pitsiladis, P. S. Stefaneas 59 x(a:T).Px(a)− − → P(In) x⟨y⟩.Px⟨y⟩− − → P (Out) τ.Pτ− →P(Silent) Pl− →P′ !Pl− →P′|!P(Repl)P1l− →P′ 1 P1+P2l− →P′ 1(Choice) Pl− →P′ [x=x](P;Q)l− →P′(CondT)Ql− →Q′x̸=y [x=y](P;Q)l− →Q′(CondF) Sl− →S′ R[S]l− →R[S′](ResGS)Pl− →P′ G:u[P]l− →G:u[P′](ResGP) Fx⟨a0⟩− − − → F′ (νa:T)F(νa0:T)x⟨a0⟩− − − − − − − → F′(Open)Fl− →F′a0/∈fn(l) (νa:T)F[shiftdown al]− − − − − − − − → (νa:T)F′(ResN) F1x(a)− − → F′ 1 F2x⟨z⟩− − → F′ 2 F1|F2τ− →([a:=z]F′ 1)|F′ 2(Comm)F1x(a)− − → F′ 1 F2(νbn:T)x⟨bn⟩− − − − − − − → F′ 2 F1|F2τ− →(νb:T)(([a:=bn]F′ 1)|F′ 2)(Close) F1l− →F′ 1 bn(l)∩fn(F2) =/ 0 F1|F2l− →F′ 1|F2(Par)F1≡F2 F2l− →F F1l− →F(Congr) Figure 3: The rules of labelled transition semantics of the Privacy Calculus. fn (X)is the set of free names of the term X, while bn (X)is the set of its bound names. Rules that contain the variable Fare applicable both to processes and systems. 4 Converting BPMN to Privacy Calculus 4.1 Main considerations regarding conversion In the spirit of [19, 20, 1], a BPMN Process will be converted to a Privacy Calculus term consisting of the concatenation of terms corresponding to every Flow Node (i.e. Event, Activity, or Gateway) within the Process. Flows will be converted to channels that serve for communication between processes: Sequence Flows will carry tokens, while Message Flows will carry messages (possibly containing data important to privacy policies). Every Privacy Calculus process corresponding to a Flow Node will then have (roughly)3the following structure: (1) begin with receiving tokens via its incoming Sequence Flows, (2) continue with receiving Messages via its incoming Message Flows, (3) do any work specific to its type, 3As [19, Section 4] points out, “The description given applies only to basic control flow structures. Advanced structures require slightly different approaches.”; in fact, various of the patterns presented in [19, 20] and in Section 4.3 of this paper diverge (slightly or more radically) from the rough structure above. Moreover, “if a process representing [a Flow Node] can be triggered more than once, the replication operator must be used” and “a [conditional] prefix [after receiving the triggers] can be used to model global constraints like testing a cancellation flag” (the latter is in fact taken into account in the basic description given in [19], but is left out here).

[Página 8]
60 Converting BPMN Diagrams to Privacy Calculus (4) send messages via its outgoing Message Flows, (5) pass token(s) to its outgoing Sequence Flow(s); some outgoing Sequence Flows might be affected by conditions, hence only be triggered conditionally. This design choice is influenced by [19]: “A generic process can have mincoming triggers [. . .] and o outgoing triggers. [. . .] After the input prefixes have been triggered [. . .] First, the functional perspective of the activity is represented as an unobservable action. Second, the process can trigger other processes by output prefixes.” [19, Section 4]. Here, we have “unfolded” a small part of the unobservable action so as to accommodate Message Flows and considered that some outgoing Sequence Flows are only conditionally triggered. In order to accommodate Sequence Flows, the set Tof types is presumed to contain a special type Token of tokens. For simplicity, values of this type will always be denoted by t, assuming that this name is not used for any other element. Notice that “a token does not traverse a Message Flow since it is a Message that is passed down a Message Flow (as the name implies)” [14, Section 7.2]. Hence, for every Message Flow, the name and type (as an element of T) of the Message needs to be known; types of Messages are not a part of BPMN and, as stressed in Section 2, names of Messages will need to be provided externally to BPMN. 4.2 Flow patterns In [19, 20], various patterns common to business processes are identified and their conversion to π- calculus processes is discussed. We will review a few here (Sequence, Parallel split, Exclusive choice, Synchronisation, N–out–of–M–join) and present some variations of them (Choice, n–out–of– nsynchro- nisation, m–out–of– nsynchronisation). While discussing flow patterns, the following notation will be adopted: (1) Instead of BPMN Flow Nodes and Flows, arbitrary nodes and edges (in the graph theoretic sense) will be considered. (2) The conversion of a node Xinto a Privacy Calculus term will be denoted ∥X∥. (3) Since only the initial and/or final behaviour of Xwill be of interest, there will be a part of ∥X∥that will be irrelevant to this discussion (in fact, it will depend on what kind of BPMN element Xis); this will be denoted by X′. Sequence: The simplest pattern, defined in [19, Section 4.1]. Suppose that node Ahas a unique outgoing edge f. Then, A, when it has finished its work, needs only trigger the next node by sending a token via f, i.e.∥A∥:=A′.f⟨t⟩.0. Similarly, suppose that node Bhas a unique incoming edge f. Then, Bwaits until it receives the token and then starts its own work, i.e. ∥B∥:=f(t:Token ).B′. 4.2.1 Outgoing Suppose that node Ahas multiple outgoing edges f1,..., fn(n≥2) to other nodes. Parallel split: In this pattern, defined in [19, Section 4.1], Atriggers all of its outgoing edges in parallel. For n=2, this can be achieved with ∥A∥:=A′.(f1⟨t⟩.0|f2⟨t⟩.0). This can be generalised to ∥A∥:=A′.∏n i=1fi⟨t⟩.0. Exclusive choice: In this pattern, defined in [19, Section 4.1], Atriggers exactly one of its outgoing edges. For n=2, this can be achieved with ∥A∥:=A′.(f1⟨t⟩.0+f2⟨t⟩.0). This can be generalised to ∥A∥:=A′.∑n i=1fi⟨t⟩.0.

[Página 9]
G. V . Pitsiladis, P. S. Stefaneas 61 4.2.2 Incoming Suppose that node Bhas multiple incoming edges f1,..., fn(n≥2) from other nodes. Choice: In this pattern, Bwaits for any of its incoming edges to be triggered and then starts. Input from the rest of the edges is disregarded. For n=2, this can be achieved with ∥B∥:=f1(t:Token ).B′+f2(t: Token ).B′. This can be generalised to ∑n i=1fi(t:Token ).B′. If multiple incoming edges can be activated, then the choice pattern will process only one of them, leaving the rest “hanging”. Depending on the situation at hand, this might be alleviated (if needed) either by creating a new copy of Bfor each incoming trigger (similarly to the Multi-merge pattern of [19, Section 4.2]) or by the 1-out-of-n synchronisation pattern below. Synchronisation: In this pattern, defined in [19, Section 4.1], Bwaits for all of its incoming edges to be triggered—in a predefined order, however—before it starts. For n=2, this can be achieved with ∥B∥:=f1(t:Token ).f2(t:Token ).B′. This can be generalised to f1(t:Token )....fn(t:Token ).B′. We will not use this pattern in Section 4.3, opting for the n-out-of- nandm-out-of- nvariants below. The reason is twofold. First, notice that, in general, this pattern might create deadlock issues; for instance, consider Atriggering both CandB(via f2) and Ctriggering B(via f1): if the outgoing pattern used by A waits for f2to be consumed before triggering C, then Bwill never be executed. Moreover, even if such deadlocks are guaranteed to be impossible, ∥B∥will be behaviourally different depending on the order thefiare written; this asymmetry might be undesired in applications such as the one of Section 4.4 (e.g. it might complicate unit testing, since a single input will have multiple non-equivalent correct outputs). n–out–of– nsynchronisation: In this pattern (similar to N-out-of-M-join of [19, Section 4.2]), B(run on behalf of group G) waits for all of its incoming edges to be triggered before it starts, consuming every trigger as it arrives. For n=2, this can be achieved with ∥B∥:= (νh:G[Token ])h(t:Token ).h(t:Token ).B′|f1(t:Token ).h⟨t⟩.0|f2(t:Token ).h⟨t⟩.0, where hmust not be free in B′. This can be generalised to ∥B∥:= (νh:G[Token ])h(t:Token )....h(t:Token ).| {z } ntimesB′|n ∏ i=1fi(t:Token ).h⟨t⟩.0. The drawback of this pattern is that it creates a fresh name. Applications such as the one of Section 4.4 need to select a name not among the free names of B′. Moreover, it might complicate unit testing: either the selected name must be known when writing tests or α-equivalence must be tested instead of equality. m–out–of– nsynchronisation: In this pattern, generalising the previous one, B(run on behalf of group G) waits for exactly m≤nof its incoming edges to be triggered before it starts, consuming however all ntriggers as they arrive. For n=2 and m=1, this can be achieved with ∥B∥:=(νh:G[Token ])(νr:G[Token ]) r(t:Token ).B′|f1(t:Token ).h⟨t⟩.0|f2(t:Token ).h⟨t⟩.0|h(t:Token ).r⟨t⟩.h(t:Token ).0, where handrmust not be free in B′. This can be generalised to ∥B∥:=(νh:G[Token ])(νr:G[Token ])r(t:Token ).B′|n ∏ i=1fi(t:Token ).h⟨t⟩.0| h(t:Token )....h(t:Token ).| {z } mtimesr⟨t⟩.h(t:Token )....h(t:Token ).| {z } n−mtimes0.

[Página 10]
62 Converting BPMN Diagrams to Privacy Calculus The drawback of this pattern, as with the previous one, is that it creates fresh names. This pat- tern might be useful for the conversion of some kinds of Complex Gateways [14, Section 10.6.5] (e.g. those operating on the rule that “three out of five incoming Sequence Flows are needed to activate the Gateway”), which however are not considered here. [19, Section 4.2] defines the similar pattern N–out–of–M–join , which recursively restarts ∥B∥after having consumed all of the ninput triggers. 4.3 Conversion of diagram elements This section is the gist of this paper. In Sections 4.3.1 to 4.3.10, the conversion of every supported kind of BPMN element to Privacy Calculus is discussed. For any BPMN element N, the corresponding Privacy Calculus term will be denoted ∥N∥. 4.3.1 Start Events The most generic form of a Start Event Nis for it to have (1) no incoming Sequence Flows, (2) multiple outgoing Sequence Flows f1,..., fk, 1≤k, and (3) (if it is a Message Start Event) multiple incoming Message Flows E1,..., El, 1≤l, each carrying a message miof type Ti. According to [14, Section 10.5.2], each Message Flow targeting a Start Event represents an instanti- ation mechanism (a trigger) for the Process; only one of the triggers is required to start a new Process. Thus,∥N∥shall start with a Choice pattern among the Message Flows. Also, according to [14, Sec- tion 10.5.2], if multiple Sequence Flows originate at a Start Event, then they are considered as parallel paths; thus the Parallel split pattern shall be used. Hence, ∥N∥will be l ∑ i=1 Ei(mi:Ti).(νt:Token )k ∏ j=1fj⟨t⟩.0! , that is, Nwaits for any Eito pass a message and then, being a Start Event, generates a token. It has no further internal work to do, so it triggers all of its outgoing Sequence Flows in parallel using the Parallel split pattern. Of course, in case there are no incoming Message Flows (i.e. the Start Event is not a Message Event), ∥N∥can be simplified to (νt:Token )∏k j=1fj⟨t⟩.0. In case that a Message Start Event is part of a single Process (i.e. not in a Collaboration) or the modeller has failed to provide Message Flows, one “phantom” Message Flow can be assumed and the conversion can then still proceed as above. 4.3.2 End Events The most generic form of an End Event Nis for it to have (1) multiple incoming Sequence Flows e1,..., ek, 1≤k, (2) no outgoing Sequence Flows, and (3) (if it is a Message End Event) multiple outgoing Message Flows F1,..., Fl, 1≤l, each carrying a message miof type Ti; it is assumed here that the messages are generated within the Event. Suppose that the Process containing Nruns for group G. Contrary to [14, Section 10.5.3], if multiple Sequence Flows converge into an End Event, they will be required to be parts of parallel paths; then, according to [14, Section 10.5.3], “the tokens will be con- sumed as they arrive”. Hence, the End Event starts with a k-out-of-k synchronisation pattern. Afterwards, “Each Message Flow leaving the End Event will have a Message sent when the Event is triggered.” [14, Section 10.5.3], which indicates a Parallel split of Message Flows. Hence, for k>1,∥N∥will be (νh:G[Token ])h(t:Token )....h(t:Token ).| {z } ktimesD|k ∏ i=1ei(t:Token ).h⟨t⟩.0,

[Página 11]
G. V . Pitsiladis, P. S. Stefaneas 63 where Dis∏l j=1(νmj:Tj)Fj⟨mj⟩.0for Message End Events and 0otherwise. For k=1,∥N∥can be simplified to e1(t:Token ).D(aSequence pattern). If the End Event is part of a Sub-Process, the 0at the end of Dis replaced by a Parallel split pattern of the Sequence Flow(s) outgoing from the Sub-Process. In case that a Message End Event is part of a single Process (i.e. not in a Collaboration) or the modeller has failed to provide Message Flows, one “phantom” Message Flow can be assumed and the conversion can then still proceed as above. 4.3.3 Intermediate Events Recall that only Message Intermediate Events are considered in this paper. Every Message Intermediate Event can be the source or target (depending on whether the Event is catching or throwing) of at most one Message Flow [14, Section 10.5.4]. Moreover, contrary to [14, Section 10.5.4], here it will be assumed that every Intermediate Event has at most (hence, exactly) one incoming Sequence Flow. The most generic form of a Message Intermediate Event Nis hence for it to have (1) one incoming Sequence Flow e1, (2) multiple outgoing Sequence Flows f1,..., fn, 1≤n, and (3) (if it is a Message Intermediate Catch Event) one incoming Message Flow E, carrying a message m of type T, (4) (if it is a Message Intermediate Throw Event) one outgoing Message Flow F, carrying a message mof type T; it is assumed here that the outgoing message is generated within the Event. According to [14, Section 10.5.4], if multiple Sequence Flows originate at an Intermediate Event, then they are considered as parallel paths. Hence the event can use the Sequence (for incoming) and Parallel split (for outgoing) patterns and ∥N∥is e1(t:Token ).E(m:T).n ∏ j=1fi⟨t⟩.0 for Catch Events, e1(t:Token ).(νm:T)F⟨m⟩.n ∏ j=1fi⟨t⟩.0 for Throw Events. Notice that this is a simplified conversion. In fact, “if another token arrives from the same path or another path, then a separate instance of the Event will be created” [14, Section 10.5.4]. However, multiple instances of Events will not be tackled here, since that would be quite more complicated (as [19, Section 4.2] points out, “by using the replication operator to create multiple copies of a process D, all processes that are triggered by Dmust also support replication and so on. This also refers to all other patterns that create multiple copies by replication.”) and of minimal interest regarding privacy protection. In case that a Message Intermediate Event is part of a single Process (i.e. not in a Collaboration) or the modeller has failed to provide a Message Flow for the Event, one “phantom” Message Flow can be assumed and the conversion can then still proceed as above. 4.3.4 Parallel Gateways Every Parallel Gateway Nhas (1) 1 ≤kincoming Sequence Flows e1,..., ek, and (2) 1 ≤noutgoing Se- quence Flows f1,..., fn. Since Gateways have no internal operation, Parallel Gateways can be modelled using only the k-out-of-k synchronisation andParallel split patterns, i.e. for k>1,∥N∥will be (νh:G[Token ])h(t:Token )....h(t:Token ).| {z } ktimes n ∏ i=1fi⟨t⟩.0! |k ∏ i=1ei(t:Token ).h⟨t⟩.0, and for k=1 it will be simplified to e1(t:Token ). ∏n i=1fi⟨t⟩.0 .

[Página 12]
64 Converting BPMN Diagrams to Privacy Calculus 4.3.5 Exclusive Gateways Under the simplifying conventions introduced in Section 2.4, an Exclusive Gateway Ncan only have the following form: (1) multiple incoming Sequence Flows e1,..., ek, 2≤k, at most one of which will be triggered, and (2) one outgoing Sequence Flow f1. Hence, a Choice pattern for input and a Sequence pattern for output shall be adequate and ∥N∥can be ∑k i=1ei(t:Token ).f1⟨t⟩.0. 4.3.6 Tasks Under the simplifying conventions introduced in Sections 2.2 and 2.3, the most generic form of a Task Nis for it to have (1) one incoming Sequence Flow e1, (2) 0 or 1 incoming Message Flows E(1 in case the Task is a Receive Task), carrying a message mEof type TE, (3) multiple outgoing Sequence Flows f1,..., fn, 1≤n, where, if the Task is a Receive Task, each fimight have a condition ciattached (cicompares mEto some constant value viviaoi, where oican be either =or̸=), (4) 0 or 1 outgoing Message Flows F(1 in case the Task is a Send Task), carrying a message mFof type TF; it is assumed here that the outgoing message is generated within the Task. Outgoing Sequence Flows of Tasks need a Parallel split pattern, since “if there are multiple outgoing Sequence Flows, then this means that a separate parallel path is being created for each Sequence Flow” [14, Section 10.3]. For each other Flow kind, since at most one item exists, the Sequence pattern suffices. In [19, Section 4], it is argued that “a process that represents an activity must have a functional part represented by τ”; recall that the τ.prefix in Privacy Calculus encodes that some unspecified internal work is performed. This is indeed compatible with the fact that Tasks are used in BPMN “when the work [. . .] is not broken down to a finer level of [. . .] detail” [14, Section 7.3.2]. Hence, ∥N∥will be e1(t:Token ).E(mE:TE).τ.(νmF:TF)F⟨mF⟩.n ∏ i=1[mEoivi]fi⟨t⟩.0 where E(m:T).shall be omitted if there is no E,(νm:T)F⟨m⟩.shall be omitted if there is no F, and [mEoivi]shall be omitted if there is no ci. For a Send/Receive Task, the τ.shall be omitted, since there is no internal work other than sending/receiving the Message ([14, Section 10.3.3] stresses that once the Message has been sent/received, the Task is completed). Notice that this is a simplified conversion. In fact, similarly to Intermediate Events, “if another token arrives from the same path or another path, then a separate instance of the Activity will be created” [14, Section 10.3]. This will not be considered here, with a same rationale as for Intermediate Events. In case that a Receive/Send Task is part of a single Process (i.e. not in a Collaboration) or the modeller has failed to provide a Message Flow for the Task, one “phantom” Message Flow (incoming for Receive, outgoing for Send) can be assumed and the conversion can then still proceed as above. 4.3.7 Processes As already mentioned in Section 4.1, a BPMN Process will be converted to a Privacy Calculus term consisting of the concatenation of Privacy Calculus subprocesses corresponding to every Flow Node within the Process. In fact, since we are interested in privacy protection, a top-level Process (i.e. not part of a Collaboration and not a Sub-Process) must be decorated with a group Gthat runs the Process and a purpose ufor which it is run, so that it can be checked for compliance to privacy policies.

[Página 13]
G. V . Pitsiladis, P. S. Stefaneas 65 Notice that “each Start Event is an independent Event” [14, Section 10.5.2], hence in case of mul- tiple Start Events in the same Process (something permitted but not recommended in BPMN [14, Sec- tion 10.5.2]), the first one to be triggered invalidates (for the Process instance that is created) the rest. Consider a Process N. Let ENbe the set of Start Events of N. For every Start Event E∈EN, letAE be the set of Flow Nodes (including itself) that are accessible (in the graph-theoretic sense) via Sequence Flows from E. Let also Sbe the set of mSequence Flows which connect the nodes ofS E∈ENAE;Nmust bind the names of the channels corresponding to the Flows in order to prevent usage from the outside. Given the considerations above, ∥N∥will be the Privacy Calculus system G:u (νf1:G[Token ])...(νfm:G[Token ])| {z } for all fi∈S,i=1,..., m∑ E∈EN∏ A∈AE∥A∥ . 4.3.8 Sub-Processes Under the conventions of Sections 2.2 and 2.3, the most generic form of a Sub-Process Nis for it to have (1) one incoming Sequence Flow e1, (2) multiple outgoing Sequence Flows f1,..., fn, 1≤n, (3) a non-empty set Mof Flow Nodes and Flows within it. LetFbe the process ∏n i=1fi⟨t⟩.0(Parallel split of the outgoing Sequence Flows). Then ∥N∥will be e1(t:Token ).∥M∥, where Mis converted as a Process (Section 4.3.7), with the exceptions that (1) as noted in Section 4.3.2, End Events of Sub-Processes are converted in a special manner: as their final step, instead of a plain 0, they contain F, thus shifting flow control back to the process that contains N, (2) a Sub-Process is not decorated with group/purpose information: it is considered to run for the same group and purpose as the Process containing it. If Nis a multi-instance (parallel) Sub-Process, then ∥N∥ ise1(t:Token ).!∥M∥. 4.3.9 Participants A Participant Nhas, in general, one of the two following structures: • It is either a Process Mwith the (optional) information of a group/user Gthat runs it. If we make this information required and also require a purpose u, then ∥N∥can be the Privacy Calculus system G:u[∥M∥], • Or it is just a group/user G(again, the name is optional) depicted as a “black box”. In this case, we can use a variable PGfor the Privacy Calculus process, require a group and a purpose, and set ∥N∥to be the Privacy Calculus system G:u[PG]. 4.3.10 Collaborations A Collaboration Nis a non-empty collection of Participants M1,..., Mn, 1≤n, of groups G1,...Gn, along with some Message Flows F1,..., Fk, 0≤k, each Ficarrying a Message of type Tibetween two Participants pertaining to groups Gi,1andGi,2. In addition to containing Participants, the converted term of the Collaboration needs to bind the Message Flows (for exactly the same reasons as Process binds Sequence Flows) and declare the group combinations in use. Thus, ∥N∥is G1,1∪G1,2" ...Gk,1∪Gk,2" (νF1:G1,1∪G1,2[T1])...(νFk:Gk,1∪Gk,2[Tk])n ∏ i=1∥Mi∥## .

[Página 14]
66 Converting BPMN Diagrams to Privacy Calculus 4.4 A tool that automates the conversion An open source tool that automates the conversion has been implemented and its source code is available at [15]. It is a simple web application written in HTML and Javascript (ES2022 dialect), which can run in modern web browsers. A screenshot of the app in use is shown in Fig. 4. Figure 4: A screenshot of the web app presented in Section 4.4. At the left, the imported diagram is shown and a new one can be uploaded. The middle part contains the extra information that the user needs to fill; for ease of use, the relevant Flow Nodes are highlighted when the user selects a question. The right part contains the Maude module created by the app (or the latest error that occurred). First, a BPMN XML diagram is imported. It must adhere to the assumptions mentioned in this paper. The tool uses the open source library bpmn-js to parse BPMN XML diagrams4. Afterwards, the app asks for any extra info needed. It always requests the names to be used as (1) the type of tokens, (2) the value of tokens, (3) prefix of fresh names; this avoids using predefined values. Moreover, it asks for purposes and missing groups of Processes/Participants, and details (name, type, and, if “phantom”, channel) of Messages carried by (actual or “phantom”) Message Flows. Finally, a Maude module compatible with [18] is created. It contains a Privacy Calculus system S built using the conversions defined in Section 4. In order for Maude to parse it correctly, all groups, types, purposes, values of user data types, and process/system variables used in Sare first defined as terms of the module. For technical reasons having to do with the type checking algorithm of Privacy Calculus, the module also contains the context of S, i.e. a formal term specifying the types of free names of S. The Maude module can then be saved to a file and imported in the tool of [18] for further processing. 5 Conclusion and future work We have presented how some basic elements of BPMN diagrams can be converted into Privacy Calcu- lus and have provided a tool which can perform the conversion automatically and export it in a form compatible with the Maude formalisation of Privacy Calculus in [18]. 4The authors of bpmn-js have also created the app bpmn.io that can be used for creating and editing BPMN XML diagrams.

[Página 15]
G. V . Pitsiladis, P. S. Stefaneas 67 As detailed in the previous sections, a significant subset of BPMN was not considered in this paper (and in the tool), but is required for detailed modelling of business processes. It is a matter of future work to integrate more aspects of BPMN. For instance, supporting BPMN Data Objects and Data Stores would significantly boost the level of expressiveness; this can be achieved by taking advantage of some versions of Privacy Calculus that contain operators for data storage and retrieval [12, 22]. A more accurate conversion of some Events and Activities could be achieved by carefully converting Flow Nodes to account for re-triggering. This might not be quite important as far as privacy is con- cerned5, since a business process is compliant iff every path is compliant, hence re-triggering a path or triggering another one is irrelevant. Of course, sound conversion6is important for other reasons. The toolchain of Privacy Calculus can (and should) also be complemented with more tools. For instance, a workflow for proving compliance of programs to policies would require tools that aid in the declaration of privacy policies, either by offering GUIs for the policy language of Privacy Calculus or by converting from more user-friendly frameworks. References [1] Riad Boussetoua, Hammadi Bennoui, Allaoua Chaoui, Khaled Khalfaoui & Elhillali Kerkouche (2015): An automatic approach to transform BPMN models to Pi-Calculus . In: 2015 IEEE/ACS 12th International Con- ference of Computer Systems and Applications (AICCSA) , pp. 1–8, doi:10.1109/AICCSA.2015.7507176. ISSN: 2161-5330. [2] Bert de Brock (2024): Assigning Declarative Semantics to Some UML Activity Diagrams and BPMN Dia- grams . In Boris Shishkov, editor: Business Modeling and Software Design , Springer Nature Switzerland, Cham, pp. 65–82, doi:10.1007/978-3-031-64073-5_5. [3] Egon Börger & Ove Sörensen (2011): BPMN Core Modeling Concepts: Inheritance-Based Execution Se- mantics . In David W. Embley & Bernhard Thalheim, editors: Handbook of Conceptual Modeling: The- ory, Practice, and Research Challenges , Springer, Berlin, Heidelberg, pp. 287–332, doi:10.1007/978-3-642- 15865-0_9. [4] Flavio Corradini, Chiara Muzi, Barbara Re, Lorenzo Rossi & Francesco Tiezzi (2022): BPMN 2.0 OR-Join Semantics: Global and local characterisation .Information Systems 105, p. 101934, doi:10.1016/j.is.2021.101934. [5] Flavio Corradini, Andrea Polini, Barbara Re & Francesco Tiezzi (2016): An Operational Semantics of BPMN Collaboration . In Christiano Braga & Peter Csaba Ölveczky, editors: Formal Aspects of Component Soft- ware , Springer International Publishing, Cham, pp. 161–180, doi:10.1007/978-3-319-28934-2_9. [6] Remco Dijkman & Pieter Van Gorp (2010): BPMN 2.0 Execution Semantics Formalized as Graph Rewrite Rules . In Jan Mendling, Matthias Weidlich & Mathias Weske, editors: Business Process Modeling Notation , Springer, Berlin, Heidelberg, pp. 16–30, doi:10.1007/978-3-642-16298-5_4. [7] Remco M. Dijkman, Marlon Dumas & Chun Ouyang (2008): Semantics and analysis of busi- ness process models in BPMN . Information and Software Technology 50(12), pp. 1281–1294, doi:10.1016/j.infsof.2008.02.006. [8] Outman El Hichami, Mohamed Naoum, Mohammed Al Achhab, Ismail Berrada & Badr Eddine El Mo- hajir (2015): Towards a Formal Semantics and Analysis of BPMN Gateways . In Ahmed Bouajjani & 5At least at the current level of maturity of the Privacy Calculus ecosystem: if policies became more expressive (e.g. if they placed restrictions on how much orhow often data is processed), then consideration of re-triggering would be required. 6The BPMN standard does not define a formal semantics for diagrams, resting only on the treatment of tokens. Multiple researchers have proposed formalisations of (parts of) BPMN semantics in different frameworks: a few are [7, 6, 3, 24, 13, 8, 5, 4, 2]. Hence, soundness is in general not uniquely determined, since it depends on the selected formalisation.

[Página 16]
68 Converting BPMN Diagrams to Privacy Calculus Hugues Fauconnier, editors: Networked Systems , Springer International Publishing, Cham, pp. 474–478, doi:10.1007/978-3-319-26850-7_34. [9] Eleni Kokkinofta & Anna Philippou (2014): Type Checking Purpose-Based Privacy Policies in the π- calculus . In: Web Services, Formal Methods, and Behavioral Types , Lecture Notes in Computer Science, Springer, Cham, pp. 122–142, doi:10.1007/978-3-319-33612-1_8. [10] Dimitrios Kouzapas & Anna Philippou (2014): A Typing System for Privacy . In Steve Counsell & Manuel Núñez, editors: Software Engineering and Formal Methods , Springer International Publishing, Cham, pp. 56–68, doi:10.1007/978-3-319-05032-4_5. [11] Dimitrios Kouzapas & Anna Philippou (2015): Type Checking Privacy Policies in the π-calculus . In: For- mal Techniques for Distributed Objects, Components, and Systems , Lecture Notes in Computer Science, Springer, Cham, pp. 181–195, doi:10.1007/978-3-319-19195-9_12. [12] Dimitrios Kouzapas & Anna Philippou (2017): Privacy by typing in the π-calculus .Logical Methods in Computer Science 13(4), doi:10.23638/LMCS-13(4:27)2017. [13] Vitus Lam (2012): A Precise Execution Semantics for BPMN .IAENG International Journal of Computer Science 39. [14] Object Management Group (2013): Business Process Model and Notation . Available at https://www.omg. org/spec/BPMN/2.0.2 . Version 2.0.2. [15] Georgios V . Pitsiladis: BPMN to Privacy Calculus converter , doi:10.5281/zenodo.13235352. [16] Georgios V . Pitsiladis (2016): Type checking conditional purpose-based privacy policies in the π-calculus . In:1st Workshop for Formal Methods on Privacy , Limassol, Cyprus. Available at https://easychair. org/publications/preprint/Nnd7 . [17] Georgios V . Pitsiladis (2016): Type checking privacy policies in the π-calculus and its executable imple- mentation in Maude . Diploma thesis (in Greek), National Technical University of Athens, Athens, Greece, doi:10.26240/heal.ntua.10994. [18] Georgios V . Pitsiladis & Petros Stefaneas (2018): Implementation of Privacy Calculus and Its Type Checking in Maude . In Tiziana Margaria & Bernhard Steffen, editors: Leveraging Applications of Formal Methods, Verification and Validation. Verification , Lecture Notes in Computer Science, Springer International Publish- ing, Cham, pp. 477–493, doi:10.1007/978-3-030-03421-4_30. [19] Frank Puhlmann & Mathias Weske (2005): Using the π-Calculus for Formalizing Workflow Patterns . In Wil M. P. van der Aalst, Boualem Benatallah, Fabio Casati & Francisco Curbera, editors: Business Process Management , Springer, Berlin, Heidelberg, pp. 153–168, doi:10.1007/11538394_11. [20] Frank Puhlmann & Mathias Weske (2006): Investigations on Soundness Regarding Lazy Activities . In Schahram Dustdar, José Luiz Fiadeiro & Amit P. Sheth, editors: Business Process Management , Springer, Berlin, Heidelberg, pp. 145–160, doi:10.1007/11841760_11. [21] Mark-Oliver Stehr (2000): CINNI - A Generic Calculus of Explicit Substitutions and its Application to λ- ς- and π-calculi .Electronic Notes in Theoretical Computer Science 36, pp. 70–92, doi:10.1016/S1571- 0661(05)80125-2. [22] Evangelia Vanezi, Georgia M. Kapitsaki, Dimitrios Kouzapas, Anna Philippou & George A. Papadopoulos (2020): DiálogoP - A Language and a Graphical Tool for Formally Defining GDPR Purposes . In Fabiano Dalpiaz, Jelena Zdravkovic & Pericles Loucopoulos, editors: Research Challenges in Information Science , Springer International Publishing, Cham, pp. 569–575, doi:10.1007/978-3-030-50316-1_40. [23] Evangelia Vanezi, Dimitrios Kouzapas, Georgia M. Kapitsaki & Anna Philippou (2020): Towards GDPR Compliant Software Design: A Formal Framework for Analyzing System Models . In Ernesto Damiani, George Spanoudakis & Leszek A. Maciaszek, editors: Evaluation of Novel Approaches to Software Engineering , Communications in Computer and Information Science, Springer International Publishing, Cham, pp. 135– 162, doi:10.1007/978-3-030-40223-5_7. [24] Peter Y . H. Wong & Jeremy Gibbons (2011): Formalisations and applications of BPMN .Science of Com- puter Programming 76(8), pp. 633–650, doi:10.1016/j.scico.2009.09.010.