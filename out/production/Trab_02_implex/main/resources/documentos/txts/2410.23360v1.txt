
[Página 1]
Noname manuscript No. (will be inserted by the editor) How Do Developers Use Type Inference: An Exploratory Study in Kotlin Samuel W. Flint ·Ali M. Keshk · Robert Dyer ·Hamid Bagheri the date of receipt and acceptance should be inserted later Abstract Statically typed languages offer numerous benefits to developers, such as improved code quality and reduced runtime errors, but they also require the over- head of manual type annotations. To mitigate this burden, language designers have started incorporating support for type inference, where the compiler infers the type of a variable based on its declaration/usage context. As a result, type annotations are optional in certain contexts, and developers are empowered to use type inference in these situations. However, the usage patterns of type annotations in languages that support type inference are unclear. These patterns can help provide evidence for fur- ther research in program comprehension, in language design, and for education. We conduct a large-scale empirical study using Boa, a tool for mining software reposito- ries, to investigate when and where developers use type inference in 498,963 Kotlin projects. We choose Kotlin because it is the default language for Android develop- ment, one of the largest software marketplaces. Additionally, Kotlin has supported declaration-site optional type annotations from its initial release. Our findings reveal that type inference is frequently employed for local variables and variables initial- ized with method calls declared outside the file are more likely to use type inference. These results have significant implications for language designers, providing valuable insight into where to allow type inference and how to optimize type inference algo- rithms for maximum efficiency, ultimately improving the development experience for developers. Corresponding author: Samuel W. Flint University of Nebraska–Lincoln E-mail: swflint@huskers.unl.edu Ali M. Keshk University of Nebraska–Lincoln E-mail: akeshk2@huskers.unl.edu Robert Dyer University of Nebraska–Lincoln E-mail: rdyer@unl.edu Hamid Bagheri University of Nebraska–Lincoln E-mail: bagheri@unl.eduarXiv:2410.23360v1 [cs.SE] 30 Oct 2024

[Página 2]
2 Samuel W. Flint et al. Keywords Kotlin, mining software repositories, type systems, type inference, language design 1 Introduction Static typing aids developers in a number of ways: verification of type safety (Pacak et al., 2020), detection of errors (Prechelt and Tichy, 1998; Kleinschmager et al., 2012a), and as in-code documentation (Lubin and Chasins, 2021; Hanenberg et al., 2014). However, static typing can present a maintenance burden: requiring that types are annotated potentially increases cognitive load (Chalin and James, 2007; Ore et al., 2018). Additionally, static type systems may slow developers down when completing some tasks (Hanenberg, 2010; Okon and Hanenberg, 2016; Stuchlik and Hanenberg, 2011), though evidence is mixed (Mayer et al., 2012; Prechelt and Tichy, 1998; Kleinschmager et al., 2012b). To simplify code or reduce clutter (HSF Training, 2022), many statically typed languages (such as C++, Java, C#, Scala, Swift, and Kotlin) have adopted type inference, which allows type annotations to be dropped in some circumstances. Previous work has examined type systems and their effects (Mayer et al., 2012) and how developers use and conceptualize types in static type systems (Lubin and Chasins, 2021). However, as of writing, we are unaware of any work that studies in-depth how developers use type inference (though much work has been done to improve its performance (Hellendorn et al., 2018; Abraham and Erwig, 2006; Pierce and Turner, 2000)). Understanding where developers use type inference can help researchers better target type inference for future, human-subjects studies. In par- ticular, understanding the context of addition, or removal, of type annotations (i.e., changing from or to using type inference) can help to build better models of devel- oper cognition. Additionally, knowing the sorts of expressions, and locality of calls, commonly used with inferred types may be helpful to the developers and imple- menters of type inference algorithms, providing information about what to cache or how better to store the relevant information. To achieve these goals, in this paper, we perform an exploratory study on the use of the Kotlin language. Kotlin is a top-ten statically typed programming lan- guage (TIOBE, 2023; Carbonnelle, 2022; GitHub, 2023) and is the default program- ming language for Android development (the most popular mobile platform in the world). The Kotlin language has supported type inference in various forms since its initial release in 2011. Additionally, because of Kotlin’s strong interoperability with Java, we are able to study how that interoperability might affect the use of type inference. This paper offers two main contributions. First, while prior work considered how optional typing was used in dynamic languages (Souza and Figueiredo, 2014; Di Grazia and Pradel, 2022), this is the first study to investigate the usage of type inference in statically typed languages. Second, we examine the influence of different development contexts on the use of type inference. To study the use of type inference in Kotlin, we utilize the Boa infrastruc- ture (Dyer et al., 2013) to mine a large GitHub dataset consisting of almost 500k open-source Kotlin projects. First, we investigate how often developers utilize type inference (where it is available to them). Since type inference often involves assign- ment expressions, we analyze the right-hand sides of assignments to see what kinds

[Página 3]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 3 of expressions are most common. Next, we see if there are differences in the choice to use type inference in other contexts, such as mutable ( var) versus immutable (val) variables, testing versus non-testing code, and when projects also contain Java source files alongside the Kotlin source files. Finally, we consider the survivability of inference use: when type inference is (not) used, what is the probability of that changing over time? This particular analysis can help to understand whether or not type inference is used for the purposes of documentation. The main findings of our study are as follows: –Kotlin developers use type inference the most for local variables, fields, and method return types, implying this is a useful feature for future programming languages; –in Kotlin, most local variables utilize type inference while most fields do not, implying locality of the declaration plays a role; –initializers of type-inferred variables are typically calls to non-file-local methods, implying that type inference engines need to have global type knowledge; and –type annotation presence (or absence) on variables tends to avoid changing over time, implying inference tools can rely on caching more often. Given these findings, this paper makes the following contributions: –A first-of-its-kind characterization of the usage of declaration-level type inference by developers in Kotlin; –a description of common initializer expressions used for type-inferred variables; and –a survival analysis characterizing change patterns of type annotations in code. In Section 2 we provide background for type inference and how it is used in Kotlin. We then describe our research questions in Section 3.1 and our methods in Section 3. Next, we provide our results in Section 4 and consider the limitations in Section 5. We discuss the implications of the results in Section 6 and consider the relation to prior works in Section 7. Finally, we conclude in Section 8. 2 Background In this section, we provide some brief background on the Kotlin language, discuss type inference generally, and discuss where type inference can be used in Kotlin. 2.1 Kotlin Language As readers may not be familiar with Kotlin, we provide some brief background on some of its language features. Kotlin targets the Java VM with full interoperability with existing Java libraries. It is a statically typed language but also supports type inference in several locations (see Section 2.3). One of the goals of the language design was to make it easier for developers to write code that is more concise than typically written in Java, by providing specialized syntax and various features like data classes, destructuring, and support for building domain-specific languages (DSLs). A full discussion of Kotlin’s language is out of the scope of this work, but here we mention a few relevant features. Kotlin allows developers to control variable

[Página 4]
4 Samuel W. Flint et al. 1// global variables 2var g:Int = 7 3 4// class / object fields ( properties are implicit , and ←◁arrowhookright ignored no matter their inference status ) 5class C { 6 var x:Int = 5 7} 8 9// return types of single - expression functions 10 fun square (x :Int):Int = x * x 11 12 fun hypotenuse (x :Int, y :Int):Double { 13 // local variable declarations 14 val x2:Double = square (x). toDouble () 15 val y2:Double = square (y). toDouble () 16 return Math . sqrt (x2 + y2) 17} 18 19 fun makelist (x :Int):MutableList <Int>{ 20 var lst :MutableList <Int>= mutableListOf < Int>() 21 // loop iterator variables 22 for (i:Int in1..x) 23 lst .add (i) 24 return lst 25} 26 27// lambda argument lists 28 fun factN (n :Int) = ( makelist (n) as List<Int> ). fold (1) 29 { acc :Int, i :Int -> acc * i } 30 31 fun main () { 32 // Implicit Destructuring Declarations 33 for ((a :Int, b :Int)inmakelist (g).map ({ x :Int ->←◁arrowhookright Pair (x, factN (x)) })) { 34 println (" $a ,$b") 35 } 36} Fig. 1: Example type inference locations in Kotlin. Developers can omit code in gray and the compiler will try to infer the type. Type annotations in reddo not support inference and must be supplied by the developer.

[Página 5]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 5 mutability by choosing between immutable variables that may only be assigned to once ( val, e.g., Figure 1 line 14) and mutable (var, e.g., line 2) keywords when declaring variables. There is also support for “single-expression functions” (line 10), denoted using an equal sign rather than curly braces. Such functions implicitly return the value computed by the expression on the right-hand side of the definition. 2.2 Type Inference Type inference is often used in the context of statically typed languages, though some implementations of dynamically typed languages use it for optimization. Static type systems can be relatively simple (e.g., nominal type systems) or more complex (e.g., structural type systems). In either case, static typing generally presents several benefits to developers (Mayer et al., 2012; Stuchlik and Hanenberg, 2011), such as a potential documentary effect (Spiza and Hanenberg, 2014), memory support (Lubin and Chasins, 2021), or as a useful prototyping and domain modeling tool (Lubin and Chasins, 2021). Static type systems can also be used to ensure code correctness in various ways (Colazzo et al., 2004) or support memory management (Montenegro et al., 2008) (e.g., Rust’s ownership system (Klabnik and Nichols, 2022)). Such benefits come with a trade-off, requiring users to manually annotate the type of every variable in the system. Type inference provides a way to help balance the benefits and the trade-offs, by allowing developers to omit specifying type an- notations in certain places. The compiler then statically determines the type using constraint-solving techniques. Next, we describe how and where type inference is supported in Kotlin. 2.3 Type Inference in Kotlin Because the focus of this study is the use of type inference, we consider specifically the locations in Kotlin code where type inference is allowed. The official Kotlin spec- ification (Akhin and Belyaev, 2020) describes these locations as follows (examples are shown in Figure 1 in gray boxes): –global variables (line 2), –class/object fields (line 6), –return types of single-expression functions (line 10), –local variable declarations (lines 14–15, 20), –loop iterator variables (lines 22 and 33), and –lambda arguments lists (line 29). Certain locations do not support type inference and developers are required to provide a type annotation. Many of these locations also implicitly mark the variables as immutable (i.e., implicitly declared with the valkeyword). Some examples of locations where type inference is not supported (examples are shown in Figure 1 in red boxes): –method/function parameters (lines 10, 12, 19) –casts (line 28) –return type of functions with block bodies (lines 12, 19)–note that the type can be omitted, but then it is always assumed to be of type Unit

[Página 6]
6 Samuel W. Flint et al. Finally, in declarations where type inference is otherwise permitted, to use type inference an initializer expression must be present. If an initializer expression is not present, then a type annotation must be provided. So while immutable declarations do allow deferred assignment, if the assignment is deferred, the declaration site must contain a type annotation. 3 Methodology In this section, we describe the dataset used (Section 3.2), filtering and data prepa- ration (Section 3.3), the measurements used (Section 3.4), and our analysis methods (Section 3.5). 3.1 Research Questions As type inference is becoming increasingly popular in modern programming lan- guages, understanding where and how often developers utilize it can help provide insights into future language designs. To that end, we study the Kotlin language, the default programming language for Android, the most popular mobile operating system. RQ1 How often do Kotlin developers use type inference? Kotlin supports type inference in specific locations, but developers are not required to use it. Understanding the frequency of use of type inference may help to understand where developers prefer manually adding type annotations. Based on the results observed when answering this question, and because different code contexts present different challenges to developers, we then look deeper to see if certain contexts affect the use of type inference. RQ2 Is type inference used differently in different contexts? Where type inference is used, does that use differ depending on the development context? Here we consider four sub-questions, corresponding to four different contexts we observed: a) Is type inference used more frequently with certain kinds of initializer expressions? Here we consider local variables, and the types of expressions on the right-hand side (e.g., literal, variable access, method call) to see what expression kinds are used more frequently. b) Is the use of type inference different for immutable variables (declared with val) or mutable variables (declared with var)?Is there a relationship between mutability and the usage of type inference? c) Is the usage of type inference different in testing classes? As the goals of writing tests are different from writing non-testing code, the usage of type inference may also be different. d) Is the usage of type inference different in Kotlin projects con- taining both Kotlin and Java source files? Since Kotlin projects can also include Java source files, and Java supports type inference in fewer locations, the presence of Java source files may influence the behavior of Kotlin developers.

[Página 7]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 7 Finally, based on our personal experience, we have rarely seen code with a type annotation remove that type over time. What is less clear, however, is if variables utilizing type inference (that is, which are originally declared without a type annota- tion) eventually add a type annotation. Reasons to do so might be for documentation or to place additional constraints on the inference algorithm to help it infer the cor- rect types elsewhere. RQ3 Does the use of type inference change over time by adding or re- moving type annotations? 3.2 Dataset We use the “2021 Aug/Kotlin” Boa (Dyer et al., 2013, 2021) dataset (containing 499,645 projects), which is composed of nearly all of the open-source Kotlin projects publicly available from GitHub at the time the dataset was cloned in the summer of 2021. Boa builds datasets by using the GitHub API to find project metadata and then cloning the Git repositories for those projects. It then converts that data into a custom AST format for easier querying. This dataset is selected because of its usability and broadly representative nature. Within the dataset, we find small (even toy) projects as well as large, well-known Kotlin projects, such as leakcanary ,1 Shadowsocks for Android,2and the anko library for Android development.3We include projects of all sizes to see if there is a relationship between project size and the usage of type inference. Table 1: Analyzed repositories and files (file-level deduplication not accounted for). Raw Dataset Filtered Projects 499,645 498,963 Source Files (HEAD) 9,604,478 9,604,206 Snapshots 37,866,871 37,865,222 The number of raw projects in the dataset is shown in Table 1, and the number of commits, files, and statements are shown in Table 2. Median Kotlin projects tend to be young (3 commits) and small (9 files). 3.3 Filtering and Data Preparation To ensure that detected uses of type inference are relevant, we filter some projects from the dataset. We filtered projects which had no parseable Kotlin files or for which the only Kotlin file was build.gradle.kts . After filtering, we prepared the data using the Boa Study Template (Dyer and Flint, 2022). Additionally, for some research questions (RQ2(a) and RQ3), we re- moved duplicates at the file level, as suggested by Lopes et al. (2017). For this, 1https://github.com/square/leakcanary 2https://github.com/shadowsocks/shadowsocks-android 3https://github.com/Kotlin/anko/

[Página 8]
8 Samuel W. Flint et al. Table 2: Repository size statistics. mean std min 25% 50% 75% max Main Branch Commits 14.80 114.11 1 1 3 10 14,723 Number of Committers 2.02 34.59 0 1 1 2 7,724 Number of Files 19.25 77.15 1 4 9 20 36,021 Number of Files (Deduped) 8.53 64.57 1 2 2 5 11,998 Number of Statements 406.00 2,484.82 1 46 125 330 1,101,330 Number of Stars 3.33 135.21 0 0 0 0 38,979 we collected the AST hash of each file in the HEAD snapshot of each project and selected for analysis only one file-project pair for each hash. 3.4 Measurements We collect data about five features: i) declaration site; ii) usage of type inference; iii) initializer expression type; iv) initializer method call locality, and v) time from creation to change in inference status. Additionally, for RQ1 and RQ2 we consider each repository’s HEAD commit snapshot. For RQ3, we consider changes over time. RQ1: Declaration Site Detection As type inference is not allowed in all variable declaration locations, we must be careful to only mine those where it is available. This is done through selectively visiting explicit variable declarations, based on the locations which are available as described in Section 2.3. RQ1: Detecting Type Inference We detect whether or not a given declaration site uses a type annotation by analyzing the Boa AST. In Boa’s AST, all variable declarations are represented as a Variable object, which contains a type field. If this field is defined, the variable has a type annotation and is thus not inferred. If instead the type field is undefined, the variable declaration uses type inference. RQ2(a): Detecting Initializer Expression Types We also collect the kind of initializer expressions (when present). That is, what sort of expression is present, not the type of that expression. This information is partially available in the Boa ASTs, however determining if a call is to a method or a constructor is not straightforward, as the syntax for both is identical in Kotlin, and type information (which Boa does not provide) is required to resolve this. To resolve the difference between calls to methods and constructors, we use a two- pass approach. On the first pass, we collect the names of all project-local methods and classes into two separate sets. In the second pass, we use the following heuristic: if a method call name is part of the list of project-local methods or default-imported methods, we consider it to be a method call. If this first condition fails, we check to see if this is a default-imported, file-imported, or project-local class. If so, we consider it to be a constructor call. Finally, if the prior two conditions failed, we use a name-starts-with-capital-letter heuristic: if the name starts with a capital letter, we assume it to be a constructor call, otherwise, we assume it to be a method call.

[Página 9]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 9 RQ2(b): Detecting Method Call Locality Similar to the above issue with detecting method calls or constructor calls in Kotlin, we also detect whether calls to methods arefile-local (the method is declared in the same file) using a simple heuristic. While to do so perfectly would require complete type information (and thus be infeasible using the Boa infrastructure), our heuristic is complete with respect to non-local calls. For each file, we collect the names of defined methods and as we come to variable declarations with method calls in their initializers, we check to see if the name is in this list. If so, we consider it a “possibly file-local call”, if not, we consider it as a “non-file-local call” . RQ2(c): Detecting Tests To determine if a file is a test, we use two heuristics. The first (and simplest) is a test of the file path: if the lowercased path of a source file contains either test ortesting , or ends in test.kt , the file is considered a test. This is a similar heuristic that has been applied previously in many other studies (e.g., Vahabzadeh et al. (2015); Veloso and Hora (2022); Nagy and Abdalkareem (2022); Cor` o et al. (2020); Nakamaru et al. (2020); Keshk and Dyer (2023)). The second heuristic is somewhat more complicated: if a file imports one of a number of popular testing frameworks (in the testing or mocking categories on MVN Repository), it is considered a test. Our list of testing frameworks also includes popular Java testing frameworks (as Kotlin projects may use Java libraries). This is a similar approach that has also been used in previous studies (e.g., Peruma and Newman (2021); Nagy and Abdalkareem (2022)). The frameworks included:4 –Java/Kotlin Frameworks: –org.junit.* –org.scalatest.* –org.testng.* –org.springframework.test.* –org.springframework.mock.* –org.hamcrest.* –org.scalacheck.* –org.mockito.* –org.easymock.* –org.powermock.* –com.github.tomakehurst.* –org.easymock.* –org.jmock.* –org.jmockit.* –Kotlin Frameworks: –kotlin.test.* –io.mockk.* –org.spekframework.* –com.natpryce.hamkrest.* –io.kotest.* –io.strikt.* –org.amshove.kluent.* –com.winterbe.expekt.* 4https://github.com/unl-pal/kotlin-inference-study/blob/ af15202888b4f1aac6c9d748137cf7c0e6720b1e/boa/queries/common/detect-tests.boa#L5

[Página 10]
10 Samuel W. Flint et al. –assertk.* RQ2(d): Detecting Mixed Kotlin-Java Projects When investigating RQ2(d), we must be able to determine if a project contains Java code. To do this, we collect a list of all projects with at least one (parseable) Java source file in their HEAD snapshot and filter prior query results using this list. RQ3: Changing Inference Status To investigate RQ3, we collect information about type inference usage over time. In particular, we collect the lifetime of a declaration’s type inference status, that is: how long did the initial declaration stay, and how did it change, if at all. To do this, we process all commits reachable from HEAD in the order they were committed. The full algorithm is shown in Algorithm 1. Algorithm 1 Algorithm for determining inference status over time. 1:procedure ProcessRepository (reachableCommits) 2: allDeclarations←{} ▷Map from file to declarations 3: for each commit∈reachableCommits do 4: for each file∈commit do 5: knownDeclarations ←allDeclarations[file] ▷List of statuses 6: timeDifference←time(commit) - createTime (knownDeclarations, decl) 7: 8: for each decl∈knownDeclarations and̸∈filedo ▷Find removed declarations 9: knownDeclarations[decl] ←{REMOVED, inferred? (decl), timeDifference } 10: end for 11: 12: for each decl∈fileand̸∈ignored (knownDeclarations, decl) do 13: ifdecl̸∈knownDeclarations then ▷The declaration is new 14: knownDeclarations[decl] ←{ADDED, inferred? (decl), timeDifference } 15: else ▷The declaration’s inference status changed 16: ifinitialInferred (knownDeclarations, decl) ̸=inferred? (decl) then 17: knownDeclarations[decl] ←{CHANGED, inferred? (decl), timeDifference } 18: end if 19: end if 20: end for 21: 22: ifcommit is last commit then ▷Mark last observation times 23: for each decl∈knownDeclarations do 24: ifdecl̸∈ignored (knownDeclarations, decl) then 25: knownDeclarations[decl] ← { OBSERVATION ENDED, inferred? (decl), timeDifference} 26: end if 27: end for 28: end if 29: end for 30: end for 31:end procedure We then process the stack of commits as follows: –When a declaration is introduced, we store the location, type inference status, and the commit timestamp (lines 8-10). –When a declaration’s type inference status changes (shown in Algorithm 2), we compute the difference in time between the present commit and the initial commit (shown in Algorithm 3), and output location information, type inference status, time to change, and type of outcome ( CHANGED ) (line 14), and then add the location to an ignore list as shown in Algorithm 4 (since we only track time to first change).

[Página 11]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 11 Algorithm 2 Finding the initial inference status. 1:procedure initialInferred (knownDeclarations ,decl) 2: ifdecl∈knownDeclarations then 3: for each observation∈knownDeclarations[decl] do 4: ifobservation.kind isADDED then 5: return observation.inferred? 6: end if 7: end for 8: end if 9: return undefined 10:end procedure Algorithm 3 Find time of first observation, if any. 1:procedure createTime (knownDeclarations ,decl) 2: ifdecl∈knownDeclarations then 3: for each observation∈knownDeclarations[decl] do 4: ifobservation.kind isADDED then 5: return observation.time 6: end if 7: end for 8: end if 9: return 0 10:end procedure Algorithm 4 Determining if a declaration is ignored. 1:procedure ignored (knownDeclarations ,decl) 2: ifdecl∈knownDeclarations then 3: for each observation∈knownDeclarations[decl] do 4: ifobservation.kind isCHANGED then 5: return True 6: end if 7: end for 8: end if 9: return False 10:end procedure –When a declaration disappears (i.e., it is no longer found in the code, or the file is deleted), we perform the same calculations, outputting with the relevant outcome type ( REMOVED (line 17) or FILE DELETED (not shown, but treats every declaration as removed) respectively). –Finally, if the commit is the final commit, all remaining declarations in the repos- itory are processed as above, with the outcome of OBSERVATION ENDED (lines 22-28). 3.5 Analysis We consider the frequency of type inference, per project, in RQ1 as both a percentage of inferred declarations for a given location and a percentage of inferred declarations at each location based on the total number of inferrable locations in the project. This allows us to describe differences in usage between locations and allows us to consider how each location factors into overall usage frequency. We then examine the relationships between project size metrics and project-level usage of type inference using Pearson’s r(Pearson, 1900). We first verify there are no higher-order relationships between any of the project size metrics and type inference

[Página 12]
12 Samuel W. Flint et al. usage by examining scatter plots (available in the replication package (Flint et al., 2023)). For RQ2, we look deeper into the usage of type inference, examining some spe- cific contexts where type inference is used. First, we collect initializer expressions of inferred variable declarations, examining how frequently different kinds of expres- sions are used. Next, we examine how frequently method calls in initializers are to file-local methods and functions. Then, as testing is a different activity from general software development (Spadini et al., 2018; Bertolino, 2007), we look for differences in testing code by repeating our RQ1 analysis on only testing-related files. Finally, as Kotlin and Java are interoperable, with the latter having different rules for type inference, we again repeat our RQ1 analysis but on only mixed-language projects to see if the presence of Java affected inference use in Kotlin code. We also perform the Kruskal-Wallis Htest to verify differences and report the pvalues. This test is used because of the censored, non-normal nature of the data analyzed. For RQ3 we need to perform a survival analysis. Survival analysis is a method by which we can quantify and analyze the time to an event from an initial state, particularly in the presence of missing data about the time to the event (such as not knowing if the event has occurred due to attrition) (Kleinbaum and Klein, 2012). As this sort of censoring is likely in our dataset, this analysis is more useful than simply presenting mean-time-to-change. Moreover, survival curves like the Kaplan- Meier estimator (Borgan, 2014) include more information than an average, allowing for richer analysis. Table 3: Usage of type inference in Kotlin by location, as percentages of specific locations in a project (outliers included; min & max omitted as equal). Location Inferred? mean std min 25% 50% 75% max Field Inferred 26.95 25.18 0 7.14 22.00 38.89 100 Not Inferred 73.05 25.18 0 61.11 78.00 92.86 100 Global Variable Inferred 87.20 28.61 0 100.00 100.00 100.00 100 Not Inferred 12.80 28.61 0 0.00 0.00 0.00 100 Lambda Arg Inferred 92.30 22.41 0 100.00 100.00 100.00 100 Not Inferred 7.70 22.41 0 0.00 0.00 0.00 100 Local Variable Inferred 86.46 19.22 0 80.00 94.12 100.00 100 Not Inferred 13.54 19.22 0 0.00 5.88 20.00 100 Loop Var Inferred 97.92 12.83 0 100.00 100.00 100.00 100 Not Inferred 2.08 12.83 0 0.00 0.00 0.00 100 Return Type Inferred 52.05 38.76 0 11.11 50.00 100.00 100 Not Inferred 47.95 38.76 0 0.00 50.00 88.89 100 For data visualization and statistical summarization, we use the pandas li- brary (development team, 2020). We measure the strength and direction of relation- ships between type inference usage and various project size metrics using Pearson’s r(Pearson, 1900), as implemented by the scipy library (Virtanen et al., 2020). For our survival analysis, we use the Kaplan-Meier estimator (Borgan, 2014), calculated using the lifelines library (Davidson-Pilon, 2019).

[Página 13]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 13 Field Global VariableLambda ArgumentLocal VariableLoop VariableReturn Type0%20%40%60%80%100%Percent per ProjectInferred Not Inferred Fig. 2: Usage of type inference per inferable location (medians of each category sum to roughly 100%), outliers not shown. See also Table 3. Field Global VariableLambda ArgumentLocal VariableLoop VariableReturn Type0%20%40%60%80%100%Percent per ProjectInferred Not Inferred Fig. 3: Usage of type inference (as percentage) in all locations of a project (all medians sum to roughly 100%), outliers not shown. 4 Results In this section, we answer the research questions via the results.

[Página 14]
14 Samuel W. Flint et al. 4.1 RQ1: How often do Kotlin developers use type inference? The first question investigates where and how often developers use type inference in Kotlin, where allowed. We show our analysis via two plots. The first of these plots, Figure 2, shows how often, for a given location, type inference is used (that is, the medians for each pair of bars will sum roughly to 100%, e.g. for Fields the medians are around 22% and 78%). This is useful to see if a given location (fields, globals, locals, etc.) is more likely to be inferred or not. The second plot, Figure 3, looks at all locations in a given project, and shows how often type inference is used in each location, relative to the total number of locations in a given project. Here, the sums of the medians across all locations is roughly 100%. This is useful to see, for a single project, what locations appear more often and if those are inferred or not. Both plots have had outliers removed, and a full statistical summary (including outliers) for Figure 2 is shown in Table 3. We discuss these results in more detail. First, we consider per-location percentages, shown in Figure 2. In this figure, we see that some locations use type inference significantly more than others: in particular, 94% of local variables use type inference in the median project. Notably, lambda arguments are inferred 100% of the time, even in the 25thpercentile: the usage of type annotations in lambda arguments is quite rare. This pattern is seen for loop variables as well. However, it appears that fields are inferred in only about one-fourth of instances. Finding 1 In Kotlin, lambda arguments, global variables, loop variables, and local vari- ables almost always have their types inferred. Fields are often not inferred, similar to a prior study (Souza and Figueiredo, 2014). Function return types are evenly split. Next, when we look at the median values in Figure 3, we see that about 39% of type-inference-capable declarations (median lines in the blue boxes, 7.58%+0%+0%+31.43%+0%+0%=39.01%) use type inference. This means type in- ference is a popular feature, and the differences that we see in Figure 2 are reflected in the project-level data. Finding 2 Type inference is a popular feature in Kotlin, with a median of 42% of dec- larations in a project using it. Additionally, we consider the correlation between several project size metrics and overall usage of type inference (see Table 4). Overall, we see that while several correlations can be said to exist (having p-values less than 0.05), the correlations detected are small and negative. This is to say, it appears unlikely that various project size metrics are related to the use of type inference.

[Página 15]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 15 Table 4: Correlation (Pearson’s r) between overall usage of type inference and project size variables. r p Number of Files -0.07 0.00 Number of Statements -0.02 0.00 Number of Stars 0.00 0.14 Number of Developers 0.00 0.44 Finding 3 Correlations (where they exist) between percentage of type-inferred declara- tions and project size metrics are incredibly small, that is, there are no strong relations between project size and the use of type inference. 4.2 RQ2: Is type inference used differently in different contexts? Since the last research question showed the use of type inference varies based on location, in this section we look a bit deeper at how type inference is used in different contexts such as initializer expressions, (im)mutable declarations, testing code, and mixed-language projects. 4.2.1 RQ2(a): Is type inference used more frequently with certain kinds of initializer expressions? To better understand the behavior of developers with respect to type inference, we consider the kind of expression on the right-hand side (RHS) of variable declarations (i.e., the initializer). The results are shown in Figure 4. This includes all variable declarations that allow initializers, such as locals, globals, and fields. The most common kind of RHS expression is a method call, with almost 40% of all RHS expressions, followed by object instantiations (including var foo =←◁arrowhookright object {};), literals, and variable accesses. In fact, these four kinds account for over 85% of all RHS expressions in the median project. Finding 4 Method calls, followed by object instantiations, are the most common initial- izers for type-inferred variables. Given that method calls are the most common initializer for inferred variables, understanding if calls are to methods local to the module or not is important since local calls can be analyzed modularly. We counted the number of non-file-local calls and possibly file-local calls and show these results in Table 5. The results show that calls are overwhelmingly to non-file-local methods.

[Página 16]
16 Samuel W. Flint et al. Finding 5 Most method calls in inferred variable initializers are to methods that are not local to the file. To summarize, for initializer expressions of type-inferred declarations, the most common kind of expression is a non-file-local method call. 0% 20% 40% 60% 80% Inferred variable assignments (% per project)METHODCALL NEW LITERAL VARACCESS ARRAYINIT EXPRESSION CAST ARRAYACCESS STATEMENT LAMBDA ARRAY_COMPREHENSION OTHER METHOD_REFERENCE METHODDECL TYPECOMPARE Fig. 4: Most common expression types in variable initializers (per project). Table 5: Are method calls used for inference to local methods? (as defined in Sec- tion 3.4) Number of Calls Not Local 8,735,180 Possibly File-Local 871,715

[Página 17]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 17 4.2.2 RQ2(b): Is the use of type inference different for immutable variables or mutable variables? Next, we consider if variable mutability affects the usage of type inference. The results are shown in Figure 5 and Table 6. Table 6: How often variables are inferred, per project, when taking into account place and mutability status (outliers included). Location Inferred? Mutable? mean std min 25% 50% 75% max Field Inferred Mutable 20.12 22.17 0 0.00 14.29 29.69 100 Not Mutable 6.82 14.73 0 0.00 0.00 7.14 100 Not Inferred Mutable 37.34 30.20 0 8.89 34.21 60.00 100 Not Mutable 35.72 30.09 0 10.53 29.58 54.98 100 Global Variable Inferred Mutable 83.99 31.82 0 88.46 100.00 100.00 100 Not Mutable 3.21 14.73 0 0.00 0.00 0.00 100 Not Inferred Mutable 8.49 23.70 0 0.00 0.00 0.00 100 Not Mutable 4.32 17.26 0 0.00 0.00 0.00 100 Local Variable Inferred Mutable 79.34 24.24 0 67.65 86.79 100.00 100 Not Mutable 7.12 15.70 0 0.00 0.00 6.82 100 Not Inferred Mutable 10.93 17.13 0 0.00 2.95 15.79 100 Not Mutable 2.61 8.39 0 0.00 0.00 0.00 100 The most notable difference is in global variables, which, as we observed previ- ously, are almost always inferred. Here, we see that global variables are also almost always mutable, with 100% of global variables being mutable and inferred in the median project (statistically significant, with p<0.001). Local variables, however, exhibit more variation with respect to mutability. While local variables are by and large inferred, a small amount (about 10%) are immutable, with most of the immutable local variables being inferred (statistically significant, withp<0.001). Finally, most fields are mutable (about 57%), no matter the inference status. However immutable non-inferred fields are more common than mutable inferred fields (statistically significant, with p<0.001). Finding 6 Overall, we find that across the three categories of declarations, more decla- rations are mutable. Additionally, when variables are immutable, inference is used in a similar pattern to usage in mutable declarations: more immutable fields are not inferred than are inferred and more local variables are inferred than not. 4.2.3 RQ2(c): Is the usage of type inference different in testing classes? Next, we look at the use of type inference in testing code, shown in Figure 6a and Ta- ble 7. When we compare these results to Table 3, we see the use of type inference in

[Página 18]
18 Samuel W. Flint et al. Field Global VariableLocal Variable0%20%40%60%80%100%Percent per ProjectInferred Not Inferred (a) Per-project percent of type inference usage by location when considering only immutable variables. Field Global VariableLocal Variable0%20%40%60%80%100%Percent per ProjectInferred Not Inferred (b) Per-project percent of type inference usage by location when considering only mutable variables. Fig. 5: Per-project percent of type inference usage by location and mutability (outliers not shown). testing code is different than previously observed. Specifically, we see two locations with substantially different usage patterns: fields and return types. Fields see type inference used 17% more often in testing classes (statistically significant, with p < 0.001). Note, however, even in testing classes, fields are still annotated about 60% of the time. Return types, on the other hand, see quite a bit higher usage in testing code, with median projects having 88% of their instances inferred as opposed to 50% shown in Table 3, (statistically significant, with p < 0.001).

[Página 19]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 19 Finding 7 Testing code seems to use type inference more frequently, for field declarations and function return types. Table 7: Usage of inference in testing code per project by allowed location (outliers shown). Median values marked ↑green are higher than similar values in Table 3. Median values marked ↓orange are lower than similar values in Table 3. Location Inferred? mean std min 25% 50% 75% max Field Inferred 43.77 37.55 0 0.00 ↑39.10 76.92 100 Not Inferred 56.23 37.55 0 23.08 ↓60.90 100.00 100 Global Variable Inferred 86.22 29.99 0 96.49 100.00 100.00 100 Not Inferred 13.78 29.99 0 0.00 0.00 3.51 100 Lambda Arg Inferred 91.25 24.85 0 100.00 100.00 100.00 100 Not Inferred 8.75 24.85 0 0.00 0.00 0.00 100 Local Variable Inferred 98.52 8.25 0 100.00 100.00 100.00 100 Not Inferred 1.48 8.25 0 0.00 0.00 0.00 100 Loop Var Inferred 98.96 9.45 0 100.00 100.00 100.00 100 Not Inferred 1.04 9.45 0 0.00 0.00 0.00 100 Return Type Inferred 66.24 40.10 0 30.30 ↑88.00 100.00 100 Not Inferred 33.76 40.10 0 0.00 ↓12.00 69.70 100 4.2.4 RQ2(d): Is the usage of type inference different in Kotlin projects containing both Kotlin and Java source files? Finally, we look at projects that also contain Java source files. This data is a subset of the overall data, and only used in this sub-section. Of the projects studied, 12.32% include Java source files. The median project including Java source files had 7 .69% of the code in Java (mean = 12 .96%,std = 14.074). In Figure 6b and Table 8 we see type inference usage in mixed Kotlin-Java projects. These minor differences could be explained by the subsetting effect of partitioning at the project level. However, these differences are all statistically significant, with p<0.001. When comparing these results to Table 3, we see three locations that differ in their usage of type inference: fields, local variables, and return types. Fields were actually inferred more in mixed projects, while local variables and return types were inferred less in mixed projects. However the differences were all very small, ranging from 1.29%-5.23%. Finding 8 Even in the presence of Java code, type inference seems to be used similarly to its use in all projects, where the differences are overall quite small ( ∼5%).

[Página 20]
20 Samuel W. Flint et al. Field Global VariableLambda ArgumentLocal VariableLoop VariableReturn Type0%20%40%60%80%100%Percent per ProjectInferred Not Inferred (a) Usage of type inference by location in testing code. Field Global VariableLambda ArgumentLocal VariableLoop VariableReturn Type0%20%40%60%80%100%Percent per ProjectInferred Not Inferred (b) Usage of type inference by location in mixed projects. Fig. 6: Per project percent of type inference usage by location, for test classes (6a) and mixed projects (6b). (Compare to Figure 2.) 4.3 RQ3: Does the use of type inference change over time? For the last research question, we consider how type inference behavior changes over time, using a survival analysis with the Kaplan-Meier estimator. We show the results in Figure 7, where the lines are the probability of inference status surviving that long and the shaded areas represent confidence bounds. For example, the blue line represents the probability that a location using type inference would keep using it over the next 1,000 days. Overall we see the probability of survival is high, with the probability at > 1,000 days being greater than 98% in both cases. Of note, the probability that a type annotation is removed is incredibly low, with a 0.75% chance after 1,000 days. Similarly, the probability that a type annotation is added is low, at 1.75%.

[Página 21]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 21 Table 8: Usage of inference in mixed Kotlin-Java projects by allowed location (outliers shown). Median values marked ↑green are higher than similar values in Table 3. Median values marked ↓orange are lower than similar values in Table 3. Location Inferred? mean std min 25% 50% 75% max Field Inferred 26.94 21.80 0 10.67 ↑23.29 38.46 100 Not Inferred 73.06 21.80 0 61.54 ↓76.71 89.33 100 Global Variable Inferred 82.63 31.71 0 81.25 100.00 100.00 100 Not Inferred 17.37 31.71 0 0.00 0.00 18.75 100 Lambda Arg Inferred 91.60 21.29 0 99.42 100.00 100.00 100 Not Inferred 8.40 21.29 0 0.00 0.00 0.58 100 Local Variable Inferred 84.05 18.90 0 77.92 ↓88.89 98.09 100 Not Inferred 15.95 18.90 0 1.91 ↑11.11 22.08 100 Loop Var Inferred 98.20 11.21 0 100.00 100.00 100.00 100 Not Inferred 1.80 11.21 0 0.00 0.00 0.00 100 Return Type Inferred 46.62 36.69 0 8.11 ↓46.15 80.00 100 Not Inferred 53.38 36.69 0 20.00 ↑53.85 91.89 100 1 10 100 1,000 time t (days)0.98250.98500.98750.99000.99250.99500.99751.0000Estimated probability of staying in state (S(t)) Starts Inferred Starts Not Inferred Fig. 7: How long does a variable keep its annotation status? Note that the time axis is shown as logarithmic for space. Finding 9 Variable declarations do not tend to add or remove type annotations at a later date. 5 Threats to Validity In this section, we discuss threats to the construct, internal, external, and conclusion validity of our study.

[Página 22]
22 Samuel W. Flint et al. 5.1 Construct Validity Our heuristic for determining object instantiations versus method calls in Kotlin (used in RQ2(a)) may be somewhat lossy, particularly for star imports. Our fallback strategy of looking at the case of the first letter may not be perfect, but standard naming conventions (pascal-case class names and camel-case method names) mean it should be accurate if developers follow those standard conventions. A brief manual analysis of our heuristic showed a 97.6% correctness (on a sample of 385 instances, for a confidence level of 95% with 5% margin of error on an initial 14,4395,555 instance population), and a Cohen’s Kappa of κ=.9318 between the human rater and the heuristic. Thus, this threat is minimal. Correct detection of file-local calls requires complete type information, which is not available in the Boa system. Instead, our heuristic uses incomplete information and may overestimate the number of file-local calls. Since there are ten times as many non-local calls as possibly-file-local calls, this particular threat is minimized. Detection of testing files may miss tests not including the word “test” in their path and not using one of the listed testing libraries, though this technique has been utilized in prior works (Nakamaru et al., 2020; Keshk and Dyer, 2023). 5.2 Internal Validity As an exploratory study that focuses on characterizing the usage of type inference by developers in Kotlin, without attributing causality, we have few threats to inter- nal validity. However, the reasons why developers choose to use type inference in different places are unclear. As we do not have access to the developers, we are un- able to discover their reasoning or accurately determine if types were automatically annotated by tooling without developer intervention. That is, our characterizations are of artifacts, not behavior itself. 5.3 External Validity In this study, there are three major barriers to external validity. First is that this study considers only Kotlin, and generalization to other statically typed languages allowing type inference may not be possible. Other languages have differing rules for type inference, and may not have allowed it at the locations or similar time frames. Additionally, as we only study open-source GitHub repositories accessible during August 2021, our results may not apply to proprietary code or code written in newer versions of Kotlin. Finally, we do not filter out toy projects: while this means we describe general behavior, our results may present some skew because of it. However, as we note in Finding 3, as we observed no relationship between type inference usage and various project size metrics, this threat is minimized. 5.4 Conclusion Validity Because the research questions are about general patterns in the use of type inference, presenting measures of central tendency is appropriate. The use of Pearson’s rto

[Página 23]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 23 determine if there are relationships between measures of project size and usage of type inference is supported by the nature of the data. Similarly, the use of the Kaplan-Meier estimator is appropriate as we have right-censored data with respect to the amount of time a variable stays in its initial inference state. 6 Discussion Given our findings, we now consider their implications for practitioners, language designers, tool developers, and researchers. 6.1 Usage of Type Inference (Findings 1/3/6/7/8) In these findings, we see that type inference is a popular feature in Kotlin, and its usage does not change with project characteristics like size, popularity, or number of developers. However, we see that different development contexts may influence where type inference is used and the extent of use. Testing code, for instance, uses type inference more frequently in field declarations and function return types than in other places. For researchers seeking to understand the cognitive impact of using type anno- tations, the patterns observed in this study may help to provide initial evidence for future studies. Since declarations are annotated more often in some places, this suggests that developers have different information needs and further research is necessary. This is especially clear when we consider the difference between testing and non-testing code: there appears to be a categorical difference which may cause developers to not annotate fields and function return types. Finally, as type inference appears to be a frequently used feature, practicing developers may want to more carefully consider when and why they use this fea- ture, particularly given work such as Spiza and Hanenberg (2014), that found type annotations alone (i.e., without type checking) improve the usability of APIs. 6.2 Initializers Call Non-Local Methods (Findings 4/5) With non-local method calls as the most common variable initializer, we see a pos- sibility for the design of clever type checkers and type inference engines that save information in more readily accessible or usable forms to speed up their execution. If object instantiation or literal expressions were more common, then this may not be necessary, but the need to resolve types may require caching of type information separate from compilation targets. For tool developers, this knowledge may be helpful in providing information about code that is being read or edited. While def-use and similar information are already available, improving how and when this information is presented is important. More- over, hooking into a language’s type inference system may be more important than previously thought.

[Página 24]
24 Samuel W. Flint et al. 6.3 Variables Which Are Inferred Tend To Stay Inferred, and Vice Versa (Finding 9) As shown in Section 4.3, variables tend to keep their inference status over time. This result is likely most useful to implementers of languages, as it may be helpful to keep this in mind when implementing compilers: caching results of parts of type- checking information between runs may help to improve type-checking performance, particularly in simpler cases. The presence of these simpler cases, however, would need to be quantified to better make this case. This result also shows the endurance of type inference systems in Kotlin. This may confirm its usability and desirability: even as code changes, the need to annotate (or not) does not appear to change. Put differently, developers see type inference as helpful while code changes, perhaps because they do not have to re-annotate variables when types change. Additionally, this result could have implications for tool builders. If many local variables are not annotated (as suggested by our results), caching type information may be necessary to simplify the implementation of various refactorings or type changes. Finally, further research is necessary to understand the motivation for adding or removing type annotations in later commits. In particular, it may be interesting to consider internal factors (e.g., increasing complexity) as well as external factors (such as onboarding new developers) as possible correlates. 7 Related Work In this section, we consider related studies on type systems and their usage and language feature mining studies. 7.1 Type Systems and Usage Souza and Figueiredo (2014) performed a mining study considering the use of op- tional typing in Groovy. They found type annotations were used frequently in formal parameters of constructors and methods (86% and 100% medians, respectively), as well as method return types (75%), however, they were used in less than half of fields (39%) and few local variables (18%). This differs from our findings in Kotlin: fields are more frequently annotated (78%), but local variables are annotated less frequently (5.9%). Next, they consider programmer language experience and its pos- sible effect on usage of type annotations, finding that those with significant statically typed backgrounds are more likely to annotate code, followed by those with mixed- paradigm backgrounds and those from dynamically typed languages annotating the least. Finally, they correlate various project size features with type annotation usage, finding that there is no significant correlation with any of these features, including with file-churn. This is similar to our results. The main difference is their study was looking at optional typing in dynamic languages while we look at type inference in static languages. Additionally, we investigate common initializer expression kinds and mutability, as well as looking at the survivability of the type annotations.

[Página 25]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 25 Di Grazia and Pradel (2022) describe type annotation behavior of developers over time in the Python language. They note that while rare in Python, type annotations are becoming more popular; moreover, type annotations, once in place, are not up- dated, and they appear not to be removed. Instead, we consider the more general concept of survival analysis, studying how long type annotation status remains. We similarly find that type annotations are rarely removed, but also, at least in Kotlin, they are also rarely added. Other researchers examined the differences between static and dynamic typing in code comprehension for maintenance. For instance, Mayer et al. (2012) found some benefit to developers in using static typing, as did Fischer and Hanenberg (????). This is noticeable in particular when repairing type errors (Kleinschmager et al., 2012a; Hanenberg et al., 2014). Additionally, Endrikat et al. (2014) found that the benefits of static typing are strengthened with explicit documentation. However, Hanenberg (2010) found no statistically significant effect overall on time-to-completion, but found that several subjects using the dynamically-typed language completed tasks faster than others. This research focused on the benefits or drawbacks of using a specific type system, while our work focuses on how type inference is used in a specific language. On the other hand, the use of static type systems has been shown to improve the detectability of bugs, at least in JavaScript Gao et al. (2017). Moreover, Tobin-Hochstadt et al. (2017) describe a ten-year retrospective of the addition of type annotations and static typing to the Racket language, describing the evolution of an optional typing system, and some of the effort necessary to start using it. Our work provides large-scale evidence of the changes in type annotation usage in the Kotlin language, but does not consider the reasons developers may make these changes. 7.2 Language Feature Mining Studies Prior studies have considered various language features, including in Java. Dyer et al. (2014), for instance, consider how features in JLS2, JLS3, and JLS4 are adopted over time, both before and after release of those versions of the Java language. One of the features used is a limited form of type inference used in Java-language generic types. We extend to more instances of type inference, and in one of our research questions, we also consider how the use of type inference evolves over time in Kotlin projects, including consideration of the effects of new language versions on this evolution. G´ ois Mateus and Martinez (2019) and Martinez and G´ ois Mateus (2020) studied code quality in Android applications written in Kotlin and the adoption of Kotlin and migration from Java for Android applications, respectively. To the best of our knowledge, these are the earliest mining studies on Kotlin developer behavior, but they do not focus on the use of type inference in the language. That said, G´ ois Ma- teus and Martinez (2020) found that Android developers using Kotlin do use type inference, and its use has picked up. Our study more thoroughly characterizes the circumstances in which type inference is used by Kotlin developers, and does so in non-Android as well as Android contexts.

[Página 26]
26 Samuel W. Flint et al. 8 Conclusion Type inference is a popular language feature for statically typed languages, and in the Kotlin language, a clearly well-used feature. This suggests that the feature is successful with respect to developer adoption, and may be desirable in other future languages. Additionally, the initializer for inferred variables is often a method call, and often to a non-local method, potentially increasing the complexity of type infer- ence algorithms. Kotlin developers seem to use type inference more in testing code, which may require more research to see if that affects code review or maintenance of those tests (Spadini et al., 2018). Finally, variables tend to stay (not) inferred over time: developers rarely see a reason to change variable annotation status. Data Availability The Boa queries, their output, and all processing scripts are made available in a replication package on Zenodo (Flint et al., 2023). Conflict of Interest The authors declare that they have no conflict of interest. Acknowledgements This work was completed utilizing the Holland Computing Center of the University of Nebraska, which receives support from the Nebraska Research Initiative. This work was supported by the U.S. National Science Foundation under the grants CCF-1755890, CCF-2139845, CCF-2124116, and CNS-2346327. References Abraham R, Erwig M (2006) Type inference for spreadsheets. In: Proceedings of the 8th ACM SIGPLAN international conference on Pricniples and Practice of Declarative Programming, PPDP, pp 73–84, DOI 10.1145/1140335.1140346 Akhin M, Belyaev M (2020) Type Inference, JetBrains, chap 14. URL https:// kotlinlang.org/spec/type-inference.html Bertolino A (2007) Software testing research: Achievements, challenges, dreams. In: Future of Software Engineering, FOSE’07, pp 85–103, DOI 10.1109/FOSE.2007.25 Borgan Ø (2014) Kaplan-meier estimator. Wiley StatsRef: Statistics Reference On- line DOI 10.1002/9781118445112.stat06033 Carbonnelle P (2022) PYPL PopularitY of Programming Language. URL https: //pypl.github.io/PYPL.html Chalin P, James PR (2007) Non-null reference by default in java: Alleviating the nullity annotation burden. In: ECOOP 2007 - Object Oriented Programming, pp 227–247, DOI 10.1007/978-3-540-73589-2 12 Colazzo D, Ghelli G, Manghi P, Sartiani C (2004) Types for path correctness of XML queries. In: Proceedings of the Ninth ACM SIGPLAN International Conference on Functional Programming, Association for Computing Machinery, New York, NY, USA, ICFP ’04, pp 126–137, DOI 10.1145/1016850.1016869, URL https: //doi.org/10.1145/1016850.1016869

[Página 27]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 27 Cor` o F, Verdecchia R, Cruciani E, Miranda †B, Bertolino A (2020) JTeC: A large collection of Java test classes for test code analysis and processing. In: Proceedings of the 17th International Conference on Mining Software Repositories, Association for Computing Machinery, New York, NY, USA, MSR ’20, p 578–582, DOI 10. 1145/3379597.3387484, URL https://doi.org/10.1145/3379597.3387484 Davidson-Pilon C (2019) lifelines: Survival analysis in Python. Journal of Open Source Software 4(40):1317, DOI 10.21105/joss.01317 Di Grazia L, Pradel M (2022) The evolution of type annotations in python: An empirical study. In: Proceedings of the 2022 30th ACM Joint Meeting on Eu- ropean Software Engineering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE, URL https://www.software-lab.org/ publications/FSE22TypeAnnotationsStudy.pdf Dyer R, Flint SW (2022) Boa study template. URL https://github.com/boalang/ study-template/ Dyer R, Nguyen HA, Rajan H, Nguyen TN (2013) Boa: A language and infrastructure for analyzing ultra-large-scale software repositories. In: Proceedings of the 2013 International Conference on Software Engineering, IEEE, ICSE, p 422–431 Dyer R, Rajan H, Nguyen HA, Nguyen TN (2014) Mising billions of AST nodes to study actual and potential usage of java language features. In: Proceedings of the 36th International Conference on Software Engineering, ICSE, pp 779–790, DOI 10.1145/2568225.2568295 Dyer R, Nguyen HA, Rajan H, Nguyen TN (2021) Boa website. http://boa.cs. iastate.edu/boa/ Endrikat S, Hanenberg S, Robbes R, Stefik A (2014) How do api documentation and static typing affect api usability? In: Proceedings of the 36th International Conference on Software Engineering, Association for Computing Machinery, New York, NY, USA, ICSE 2014, pp 632–642, DOI 10.1145/2568225.2568299, URL https://doi.org/10.1145/2568225.2568299 Fischer L, Hanenberg S (????) An empirical investigation of the effects of type sys- tems and code completion on api usability using typescript and javascript in ms visual studio. In: Proceedings of the 11th Symposium on Dynamic Languages, SPLASH ’15, DOI 10.1145/2816707.2816720 Flint SW, Keshk AM, Dyer R, Bagheri H (2023) Replication package for “Type Inference in Kotlin: An Exploratory Study of Developer Usage Patterns” . DOI 10.5281/zenodo.13328667 Gao Z, Bird C, Barr ET (2017) To type or not to type: Quantifying detectable bugs in Javascript. In: 2017 IEEE/ACM 39th International Conference on Software Engineering, IEEE, ICSE, pp 758–769, DOI 10.1109/ICSE.2017.75 GitHub (2023) The top programming languages. URL https://octoverse.github. com/2022/top-programming-languages G´ ois Mateus B, Martinez M (2019) An empirical study on quality of Android appli- cations written in Kotlin language. Empirical Software Engineering 24:3356–3393, DOI 10.1007/s10664-019-09727-4 G´ ois Mateus B, Martinez M (2020) On the adoption, usage and evolution of kotlin features in android development. In: Proceedings of the 14th ACM / IEEE Interna- tional Symposium on Empirical Software Engineering and Measurement (ESEM), ESEM ’20, DOI 10.1145/3382494.3410676 Hanenberg S (2010) An experiment about static and dynamic type systems: Doubts about the positive impact of static type systems on development time. In: Proceed-

[Página 28]
28 Samuel W. Flint et al. ings of the ACM International Conference on Object Oriented Programming Sys- tem, Languages, and Applications, Association for Computing Machinery, OOP- SLA ’10, pp 22–35, DOI 10.1145/1869459.1869462 Hanenberg S, Kleinschmager S, Robbes R, Tanter E, Stefik A (2014) An empiri- cal study on the impact of static typing on software maintainability. Empirical Software Engineering 19:1335–1382, DOI 10.1007/s10664-013-9289-1 Hellendorn VJ, Bird C, Barr ET, Allamanis M (2018) Deep learning type inference. In: Proceedings of the 2018 26th ACM Joint Meeting on European Software Engi- neering Conference and Symposium on the Foundations of Software Engineering, ESEC/FSE, pp 152–162, DOI 10.1145/3236024.3236051 HSF Training (2022) Type inference — basic modern C++. URL https:// hsf-training.github.io/hsf-training-cpp-webpage/11-type-inference/ index.html Keshk AM, Dyer R (2023) Method chaining redux: An empirical study of method chaining in Java, Kotlin, and Python. In: Proceedings of the 20th International Conference on Mining Software Repositories, MSR, p to appear Klabnik S, Nichols C (2022) The Rust Programming Language, 2nd edn. No Starch Press, URL https://doc.rust-lang.org/book/ Kleinbaum DG, Klein M (2012) Survival Analysis, 3rd edn. Statistics for biology and Health, Springer, DOI 10.1007/978-1-4419-6646-9 Kleinschmager S, Hanenberg S, Robbes R, Stefik A (2012a) Do static type sys- tems improve the maintainability of software systems? An empirical study. In: 2012 20th IEEE International Conference on Program Comprehension (ICPC), IEEE, DOI 10.1109/icpc.2012.6240483, URL https://doi.org/10.1109/icpc. 2012.6240483 Kleinschmager S, Robbes R, Stefik A, Hanenberg S, Tanter E (2012b) Do static type systems improve the maintainability of software systems? an empirical study. In: 2012 20th IEEE International Conference on Program Comprehension (ICPC), DOI 10.1109/icpc.2012.6240483 Lopes CV, Maj P, Martins P, Saini V, Yang D, Zitny J, Sajnani H, Vitek J (2017) D´ ej` aVu: A map of code duplication on GitHub. Proceedings of the ACM on Pro- gramming Languages 1(OOPSLA):1–28, DOI 10.1145/3133908 Lubin J, Chasins SE (2021) How statically-typed functional programmers write code. Proceedings of the ACM on Programming Languages 5(OOPSLA):155, DOI 10. 1145/3485532 Martinez M, G´ ois Mateus B (2020) How and why did developers migrate Android applications from Java to Kotlin? A study based on code analysis and interviews with developers. 2003.12730 Mayer C, Hanenberg S, Robbes R, Tanter E, Stefik A (2012) An empirical study of the influence of static type systems on the usability of undocumented software. In: Proceedings of the ACM International Conference on Object Oriented Program- ming Systems Languages and Applications, Association for Computing Machinery, OOPSLA, pp 683–702, DOI 10.1145/2384616.2384666 Montenegro M, Pe˜ na R, Segura C (2008) A type system for safe memory manage- ment and its proof of correctness. In: Proceedings of the 10th International ACM SIGPLAN Conference on Principles and Practice of Declarative Programming, PPDP ’08, pp 132–162, DOI 10.1145/1389449.1389468 Nagy NA, Abdalkareem R (2022) On the co-occurrence of refactoring of test and source code. In: Proceedings of the 19th International Conference on Mining Soft-

[Página 29]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 29 ware Repositories, Association for Computing Machinery, New York, NY, USA, MSR ’22, p 122–126, DOI 10.1145/3524842.3528529, URL https://doi.org/10. 1145/3524842.3528529 Nakamaru T, Matsunaga T, Yamazaki T, Akiyama S, Chiba S (2020) An empirical study of method chaining in Java. In: Proceedings of the 17th International Con- ference on Mining Software Repositories, Association for Computing Machinery, New York, NY, USA, MSR ’20, p 93–102, DOI 10.1145/3379597.3387441 Okon S, Hanenberg S (2016) Can we enforce a benefit for dynamically typed lan- guages in comparison to statically typed ones? a controlled experiment. In: 2016 IEEE 24th International Conference on Program Comprehension (ICPC), IEEE, pp 1–10, DOI 10.1109/ICPC.2016.7503719 Ore JP, Elbaum S, Detweiler C, Karkazis L (2018) Assessing the type annotation burden. In: Proceedings of the 33rd ACM/IEEE International Conference on Auto- mate Software Engineering, ASE 2018, pp 190–201, DOI 10.1145/3238147.3238173 Pacak A, Erdweg S, Szab´ o T (2020) A systematic approach to deriving incremental type checkers. Proceedings of the ACM on Programming Languages 4(OOPSLA), DOI 10.1145/3428195 Pearson K (1900) On the criterion that a given system of deviations from the probable in the case of a correlated system of variables is such that it can be reasonably supposed to have arisen from random sampling. Philosophical Magazine 50:157– 175 Peruma A, Newman CD (2021) On the distribution of ”simple stupid bugs” in unit test files: An exploratory study. In: 2021 IEEE/ACM 18th Interna- tional Conference on Mining Software Repositories (MSR), pp 525–529, DOI 10.1109/MSR52588.2021.00067 Pierce BC, Turner DN (2000) Local type inference. ACM Transactions on Program- ming Languages and Systems 22(1):1–44, DOI 10.1145/345099.345100 Prechelt L, Tichy WF (1998) A controlled experiment to assess the benefist of pro- cedure argument type checking. IEEE Transactions on Software Engineering pp 302–312, DOI 10.1109/32.677186 Souza C, Figueiredo E (2014) How do programmers use optional typing? An empirical study. In: Proceedings of the 13th International Conference on Modularity, pp 109–120, DOI 10.1145/2577080.2582208 Spadini D, Aniche M, Storey MA, Bruntink M, Bacchelli A (2018) When test- ing meets code review: Why and how developers review tests. In: Proceed- ings of the 40th International Conference on Software Engineering, Associa- tion for Computing Machinery, New York, NY, USA, ICSE, p 677–687, DOI 10.1145/3180155.3180192, URL https://doi.org/10.1145/3180155.3180192 Spiza S, Hanenberg S (2014) Type names without static type checking already im- prove the usability of APIs (as long as the type names are correct): An empirical study. In: Proceedings of the 13th International Conference on Modularity, pp 99–108, DOI 10.1145/2577080.2577098 Stuchlik A, Hanenberg S (2011) Static vs. dynamic type systems: An empirical study about the relationship between type casts and development time. In: Proceedings of the 7th Symposium on Dynamic Languages, Association for Computing Ma- chinery, DLS, pp 97–106, DOI 10.1145/2047849.2047861 development team TP (2020) pandas-dev/pandas: Pandas. DOI 10.5281/zenodo. 3509134 TIOBE (2023) TIOBE index. URL https://www.tiobe.com/tiobe-index/

[Página 30]
30 Samuel W. Flint et al. Tobin-Hochstadt S, Felleisen M, Findler R, Flatt M, Greenman B, Kent AM, St- Amour V, Strickland TS, Takikawa A (2017) Migratory Typing: Ten Years Later. In: Lerner BS, Bod´ ık R, Krishnamurthi S (eds) 2nd Summit on Advances in Pro- gramming Languages (SNAPL 2017), Schloss Dagstuhl – Leibniz-Zentrum f¨ ur In- formatik, Dagstuhl, Germany, Leibniz International Proceedings in Informatics (LIPIcs), vol 71, pp 17:1–17:17, DOI 10.4230/LIPIcs.SNAPL.2017.17, URL https: //drops.dagstuhl.de/entities/document/10.4230/LIPIcs.SNAPL.2017.17 Vahabzadeh A, Fard AM, Mesbah A (2015) An empirical study of bugs in test code. In: 2015 IEEE International Conference on Software Maintenance and Evolution (ICSME), pp 101–110, DOI 10.1109/ICSM.2015.7332456 Veloso V, Hora A (2022) Characterizing high-quality test methods: a first empirical study. In: Proceedings of the 19th International Conference on Mining Software Repositories, Association for Computing Machinery, New York, NY, USA, MSR ’22, p 265–269, DOI 10.1145/3524842.3529092, URL https://doi.org/10.1145/ 3524842.3529092 Virtanen P, Gommers R, Oliphant TE, Haberland M, Reddy T, Cournapeau D, Burovski E, Peterson P, Weckesser W, Bright J, van der Walt SJ, Brett M, Wilson J, Millman KJ, Mayorov N, Nelson ARJ, Jones E, Kern R, Larson E, Carey CJ, Polat I, Feng Y, Moore EW, VanderPlas J, Laxalde D, Perktold J, Cimrman R, Henriksen I, Quintero EA, Harris CR, Archibald AM, Ribeiro AH, Pedregosa F, van Mulbregt P, SciPy 10 Contributors (2020) SciPy 1.0: Fundamental algorithms for scientific computing in Python. Nature Methods 17:261–272, DOI 10.1038/ s41592-019-0686-2

[Página 31]
How Do Developers Use Type Inference: An Exploratory Study in Kotlin 31 Biographies Samuel W. Flint Samuel W. Flint is a Ph.D. student advised by Robert Dyer at the University of Nebraska–Lincoln, where he also earned his BS degree. His research interests are in understanding how developers use and comprehend different language features to improve language design. Ali M. Keshk Ali M. Keshk is an undergraduate student pursuing a Bachelor of Science in Computer Science at the University of Nebraska-Lincoln. With Dr. Robert Dyer as his advisor, his research primarily involved studying the use of method chaining across multiple programming languages. Robert Dyer Robert Dyer is an assistant professor at the University of Nebraska–Lincoln School of Computing. Previously he was an assistant professor at Bowling Green State University. He received BS, MS, and Ph.D. degrees from Iowa State Univer- sity. His research is in applying mining software repository techniques to see how developers use programming languages and using data-driven approaches for lan- guage design: https://go.unl.edu/rdyer .

[Página 32]
32 Samuel W. Flint et al. Hamid Bagheri Hamid Bagheri (Senior Member, IEEE) is an associate professor at the University of Nebraska–Lincoln School of Computing. He received a Ph.D. degree in computer science from the University of Virginia. Prior to UNL, he was a postdoctoral re- searcher with the UC Irvine and MIT. His general research interests include the field of software engineering, and to date, his focus has spanned the areas of soft- ware analysis and testing, applied formal methods, and dependability analysis. He has received numerous awards for his research contributions, including the EPSCoR FIRST Award and the National Science Foundation CRII Award.